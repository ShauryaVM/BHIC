module.exports = [
"[project]/node_modules/soap/lib/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.parseMTOMResp = exports.xmlEscape = exports.splitQName = exports.findPrefix = exports.TNS_PREFIX = exports.passwordDigest = void 0;
var crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
var multipart_parser_js_1 = __turbopack_context__.r("[project]/node_modules/formidable/lib/multipart_parser.js [app-rsc] (ecmascript)");
function passwordDigest(nonce, created, password) {
    // digest = base64 ( sha1 ( nonce + created + password ) )
    var pwHash = crypto.createHash('sha1');
    var NonceBytes = Buffer.from(nonce || '', 'base64');
    var CreatedBytes = Buffer.from(created || '', 'utf8');
    var PasswordBytes = Buffer.from(password || '', 'utf8');
    var FullBytes = Buffer.concat([
        NonceBytes,
        CreatedBytes,
        PasswordBytes
    ]);
    pwHash.update(FullBytes);
    return pwHash.digest('base64');
}
exports.passwordDigest = passwordDigest;
exports.TNS_PREFIX = '__tns__'; // Prefix for targetNamespace
/**
 * Find a key from an object based on the value
 * @param {Object} Namespace prefix/uri mapping
 * @param {*} nsURI value
 * @returns {String} The matching key
 */ function findPrefix(xmlnsMapping, nsURI) {
    for(var n in xmlnsMapping){
        if (n === exports.TNS_PREFIX) {
            continue;
        }
        if (xmlnsMapping[n] === nsURI) {
            return n;
        }
    }
}
exports.findPrefix = findPrefix;
function splitQName(nsName) {
    if (typeof nsName !== 'string') {
        return {
            prefix: exports.TNS_PREFIX,
            name: nsName
        };
    }
    var topLevelName = nsName.split('|')[0];
    var prefixOffset = topLevelName.indexOf(':');
    return {
        prefix: topLevelName.substring(0, prefixOffset) || exports.TNS_PREFIX,
        name: topLevelName.substring(prefixOffset + 1)
    };
}
exports.splitQName = splitQName;
function xmlEscape(obj) {
    if (typeof obj === 'string') {
        if (obj.substr(0, 9) === '<![CDATA[' && obj.substr(-3) === ']]>') {
            return obj;
        }
        return obj.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
    }
    return obj;
}
exports.xmlEscape = xmlEscape;
function parseMTOMResp(payload, boundary) {
    var resp = {
        parts: []
    };
    var headerName = '';
    var headerValue = '';
    var data;
    var partIndex = 0;
    var parser = new multipart_parser_js_1.MultipartParser();
    parser.initWithBoundary(boundary);
    parser.onPartBegin = function() {
        resp.parts[partIndex] = {
            body: null,
            headers: {}
        };
        data = Buffer.from('');
    };
    parser.onHeaderField = function(b, start, end) {
        headerName = b.slice(start, end).toString();
    };
    parser.onHeaderValue = function(b, start, end) {
        headerValue = b.slice(start, end).toString();
    };
    parser.onHeaderEnd = function() {
        resp.parts[partIndex].headers[headerName.toLowerCase()] = headerValue;
    };
    parser.onHeadersEnd = function() {};
    parser.onPartData = function(b, start, end) {
        data = Buffer.concat([
            data,
            b.slice(start, end)
        ]);
    };
    parser.onPartEnd = function() {
        resp.parts[partIndex].body = data;
        partIndex++;
    };
    parser.onEnd = function() {};
    parser.write(payload);
    return resp;
}
exports.parseMTOMResp = parseMTOMResp; //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/soap/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"soap","version":"0.43.0","description":"A minimal node SOAP client","engines":{"node":">=10.0.0"},"author":"Vinay Pulim <v@pulim.com>","dependencies":{"axios":"^0.21.1","axios-ntlm":"^1.2.0","content-type-parser":"^1.0.2","debug":"^4.3.2","formidable":"^1.2.2","get-stream":"^6.0.1","lodash":"^4.17.21","sax":">=0.6","strip-bom":"^3.0.0","uuid":"^8.3.2","xml-crypto":"^2.1.3"},"repository":{"type":"git","url":"https://github.com/vpulim/node-soap.git"},"main":"./index.js","types":"./lib/soap.d.ts","directories":{"lib":"./lib","test":"./test"},"scripts":{"prepare":"npm run build","build":"tsc -p .","clean":"rm -rf lib","watch":"tsc -w -p .","lint":"tslint -p tsconfig.json","toc":"./node_modules/.bin/doctoc Readme.md --github --maxlevel 3","cover":"nyc --extension=.ts --reporter=lcov --reporter=html --reporter=text mocha --timeout 15000 --exit test/*-test.js test/security/*.js","coveralls":"cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js -v","docs":"typedoc --out docs","test":"mocha --timeout 15000 --bail --exit test/*-test.js test/security/*.js"},"keywords":["soap"],"license":"MIT","devDependencies":{"@types/debug":"^4.1.7","@types/express":"^4.17.13","@types/lodash":"^4.14.172","@types/node":"^11.15.54","@types/request":"^2.48.7","@types/sax":"^1.2.3","@types/uuid":"^8.3.1","body-parser":"^1.15.2","colors":"^1.3.3","coveralls":"^3.1.1","diff":"^4.0.1","doctoc":"^2.0.1","duplexer":"~0.1.1","express":"^4.16.4","finalhandler":"^1.1.1","glob":"^7.1.7","jshint":"^2.13.1","mocha":"^6.1.4","nyc":"^14.1.1","readable-stream":"~2.0.2","semver":"^5.6.0","serve-static":"^1.14.1","should":"^13.2.3","sinon":"^1.17.7","source-map-support":"^0.5.10","timekeeper":"^2.1.2","tslint":"^5.18.0","typedoc":"^0.20.37","typescript":"^3.9.10"}});}),
"[project]/node_modules/soap/lib/http.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>
 * MIT Licensed
 */ var __rest = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
exports.__esModule = true;
exports.HttpClient = void 0;
var req = __turbopack_context__.r("[project]/node_modules/axios/index.js [app-rsc] (ecmascript)");
var axios_ntlm_1 = __turbopack_context__.r("[project]/node_modules/axios-ntlm/lib/ntlmClient.js [app-rsc] (ecmascript)");
var contentTypeParser = __turbopack_context__.r("[project]/node_modules/content-type-parser/lib/content-type-parser.js [app-rsc] (ecmascript)");
var debugBuilder = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-rsc] (ecmascript)");
var url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var uuid_1 = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-rsc] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/utils.js [app-rsc] (ecmascript)");
var debug = debugBuilder('node-soap');
var VERSION = __turbopack_context__.r("[project]/node_modules/soap/package.json (json)").version;
/**
 * A class representing the http client
 * @param {Object} [options] Options object. It allows the customization of
 * `request` module
 *
 * @constructor
 */ var HttpClient = function() {
    function HttpClient(options) {
        options = options || {};
        this.options = options;
        this._request = options.request || req["default"].create();
    }
    /**
     * Build the HTTP request (method, uri, headers, ...)
     * @param {String} rurl The resource url
     * @param {Object|String} data The payload
     * @param {Object} exheaders Extra http headers
     * @param {Object} exoptions Extra options
     * @returns {Object} The http request object for the `request` module
     */ HttpClient.prototype.buildRequest = function(rurl, data, exheaders, exoptions) {
        if (exoptions === void 0) {
            exoptions = {};
        }
        var curl = url.parse(rurl);
        var method = data ? 'POST' : 'GET';
        var secure = curl.protocol === 'https:';
        var path = [
            curl.pathname || '/',
            curl.search || '',
            curl.hash || ''
        ].join('');
        var host = curl.hostname;
        var port = parseInt(curl.port, 10);
        var headers = {
            'User-Agent': 'node-soap/' + VERSION,
            'Accept': 'text/html,application/xhtml+xml,application/xml,text/xml;q=0.9,*/*;q=0.8',
            'Accept-Encoding': 'none',
            'Accept-Charset': 'utf-8',
            'Connection': exoptions.forever ? 'keep-alive' : 'close',
            'Host': host + (isNaN(port) ? '' : ':' + port)
        };
        var mergeOptions = [
            'headers'
        ];
        var _attachments = exoptions.attachments, newExoptions = __rest(exoptions, [
            "attachments"
        ]);
        var attachments = _attachments || [];
        if (typeof data === 'string' && attachments.length === 0 && !exoptions.forceMTOM) {
            headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
            headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }
        exheaders = exheaders || {};
        for(var attr in exheaders){
            headers[attr] = exheaders[attr];
        }
        var options = {
            url: curl.href,
            method: method,
            headers: headers,
            transformResponse: function(data) {
                return data;
            }
        };
        if (!exoptions.ntlm) {
            options.validateStatus = null;
        }
        if (exoptions.forceMTOM || attachments.length > 0) {
            var start = uuid_1.v4();
            var action = null;
            if (headers['Content-Type'].indexOf('action') > -1) {
                for(var _i = 0, _a = headers['Content-Type'].split('; '); _i < _a.length; _i++){
                    var ct = _a[_i];
                    if (ct.indexOf('action') > -1) {
                        action = ct;
                    }
                }
            }
            headers['Content-Type'] = 'multipart/related; type="application/xop+xml"; start="<' + start + '>"; start-info="text/xml"; boundary=' + uuid_1.v4();
            if (action) {
                headers['Content-Type'] = headers['Content-Type'] + '; ' + action;
            }
            var multipart_1 = [
                {
                    'Content-Type': 'application/xop+xml; charset=UTF-8; type="text/xml"',
                    'Content-ID': '<' + start + '>',
                    'body': data
                }
            ];
            attachments.forEach(function(attachment) {
                multipart_1.push({
                    'Content-Type': attachment.mimetype,
                    'Content-Transfer-Encoding': 'binary',
                    'Content-ID': '<' + attachment.contentId + '>',
                    'Content-Disposition': 'attachment; filename="' + attachment.name + '"',
                    'body': attachment.body
                });
            });
        // options.multipart = multipart;
        } else {
            options.data = data;
        }
        for(var attr in newExoptions){
            if (mergeOptions.indexOf(attr) !== -1) {
                for(var header in exoptions[attr]){
                    options[attr][header] = exoptions[attr][header];
                }
            } else {
                options[attr] = exoptions[attr];
            }
        }
        debug('Http request: %j', options);
        return options;
    };
    /**
     * Handle the http response
     * @param {Object} The req object
     * @param {Object} res The res object
     * @param {Object} body The http body
     * @param {Object} The parsed body
     */ HttpClient.prototype.handleResponse = function(req, res, body) {
        debug('Http response body: %j', body);
        if (typeof body === 'string') {
            // Remove any extra characters that appear before or after the SOAP envelope.
            var regex = /(?:<\?[^?]*\?>[\s]*)?<([^:]*):Envelope([\S\s]*)<\/\1:Envelope>/i;
            var match = body.replace(/<!--[\s\S]*?-->/, '').match(regex);
            if (match) {
                body = match[0];
            }
        }
        return body;
    };
    HttpClient.prototype.request = function(rurl, data, callback, exheaders, exoptions, caller) {
        var _this_1 = this;
        var options = this.buildRequest(rurl, data, exheaders, exoptions);
        var req;
        if (exoptions !== undefined && exoptions.ntlm) {
            var ntlmReq = axios_ntlm_1.NtlmClient({
                username: exoptions.username,
                password: exoptions.password,
                workstation: exoptions.workstation || '',
                domain: exoptions.domain || ''
            });
            req = ntlmReq(options);
        } else {
            if (this.options.parseReponseAttachments) {
                options.responseType = 'arraybuffer';
                options.responseEncoding = 'binary';
            }
            req = this._request(options);
        }
        var _this = this;
        req.then(function(res) {
            var body;
            if (_this.options.parseReponseAttachments) {
                var isMultipartResp = res.headers['content-type'] && res.headers['content-type'].toLowerCase().indexOf('multipart/related') > -1;
                if (isMultipartResp) {
                    var boundary = void 0;
                    var parsedContentType = contentTypeParser(res.headers['content-type']);
                    if (parsedContentType && parsedContentType.parameterList) {
                        boundary = (parsedContentType.parameterList.find(function(item) {
                            return item.key === 'boundary';
                        }) || {}).value;
                    }
                    if (!boundary) {
                        return callback(new Error('Missing boundary from content-type'));
                    }
                    var multipartResponse = utils_1.parseMTOMResp(res.data, boundary);
                    // first part is the soap response
                    var firstPart = multipartResponse.parts.shift();
                    if (!firstPart || !firstPart.body) {
                        return callback(new Error('Cannot parse multipart response'));
                    }
                    body = firstPart.body.toString('utf8');
                    res.mtomResponseAttachments = multipartResponse;
                } else {
                    body = res.data.toString('utf8');
                }
            }
            res.data = _this_1.handleResponse(req, res, body || res.data);
            callback(null, res, res.data);
            return res;
        }, function(err) {
            return callback(err);
        });
        return req;
    };
    HttpClient.prototype.requestStream = function(rurl, data, exheaders, exoptions, caller) {
        var _this_1 = this;
        var options = this.buildRequest(rurl, data, exheaders, exoptions);
        options.responseType = 'stream';
        var req = this._request(options).then(function(res) {
            res.data = _this_1.handleResponse(req, res, res.data);
            return res;
        });
        return req;
    };
    return HttpClient;
}();
exports.HttpClient = HttpClient; //# sourceMappingURL=http.js.map
}),
"[project]/node_modules/soap/lib/client.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>
 * MIT Licensed
 */ var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
exports.__esModule = true;
exports.Client = void 0;
var assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
var debugBuilder = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-rsc] (ecmascript)");
var events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
var getStream = __turbopack_context__.r("[project]/node_modules/get-stream/index.js [app-rsc] (ecmascript)");
var _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-rsc] (ecmascript)");
var uuid_1 = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-rsc] (ecmascript)");
var http_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/http.js [app-rsc] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/utils.js [app-rsc] (ecmascript)");
var debug = debugBuilder('node-soap');
var nonIdentifierChars = /[^a-z$_0-9]/i;
var Client = function(_super) {
    __extends(Client, _super);
    function Client(wsdl, endpoint, options) {
        var _this_1 = _super.call(this) || this;
        options = options || {};
        _this_1.wsdl = wsdl;
        _this_1._initializeOptions(options);
        _this_1._initializeServices(endpoint);
        _this_1.httpClient = options.httpClient || new http_1.HttpClient(options);
        return _this_1;
    }
    /** add soapHeader to soap:Header node */ Client.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {
        if (!this.soapHeaders) {
            this.soapHeaders = [];
        }
        soapHeader = this._processSoapHeader(soapHeader, name, namespace, xmlns);
        return this.soapHeaders.push(soapHeader) - 1;
    };
    Client.prototype.changeSoapHeader = function(index, soapHeader, name, namespace, xmlns) {
        if (!this.soapHeaders) {
            this.soapHeaders = [];
        }
        soapHeader = this._processSoapHeader(soapHeader, name, namespace, xmlns);
        this.soapHeaders[index] = soapHeader;
    };
    /** return all defined headers */ Client.prototype.getSoapHeaders = function() {
        return this.soapHeaders;
    };
    /** remove all defined headers */ Client.prototype.clearSoapHeaders = function() {
        this.soapHeaders = null;
    };
    Client.prototype.addHttpHeader = function(name, value) {
        if (!this.httpHeaders) {
            this.httpHeaders = {};
        }
        this.httpHeaders[name] = value;
    };
    Client.prototype.getHttpHeaders = function() {
        return this.httpHeaders;
    };
    Client.prototype.clearHttpHeaders = function() {
        this.httpHeaders = null;
    };
    Client.prototype.addBodyAttribute = function(bodyAttribute, name, namespace, xmlns) {
        if (!this.bodyAttributes) {
            this.bodyAttributes = [];
        }
        if (typeof bodyAttribute === 'object') {
            var composition_1 = '';
            Object.getOwnPropertyNames(bodyAttribute).forEach(function(prop, idx, array) {
                composition_1 += ' ' + prop + '="' + bodyAttribute[prop] + '"';
            });
            bodyAttribute = composition_1;
        }
        if (bodyAttribute.substr(0, 1) !== ' ') {
            bodyAttribute = ' ' + bodyAttribute;
        }
        this.bodyAttributes.push(bodyAttribute);
    };
    Client.prototype.getBodyAttributes = function() {
        return this.bodyAttributes;
    };
    Client.prototype.clearBodyAttributes = function() {
        this.bodyAttributes = null;
    };
    /** overwrite the SOAP service endpoint address */ Client.prototype.setEndpoint = function(endpoint) {
        this.endpoint = endpoint;
        this._initializeServices(endpoint);
    };
    /** description of services, ports and methods as a JavaScript object */ Client.prototype.describe = function() {
        return this.wsdl.describeServices();
    };
    /** use the specified security protocol */ Client.prototype.setSecurity = function(security) {
        this.security = security;
    };
    Client.prototype.setSOAPAction = function(SOAPAction) {
        this.SOAPAction = SOAPAction;
    };
    Client.prototype._initializeServices = function(endpoint) {
        var definitions = this.wsdl.definitions;
        var services = definitions.services;
        for(var name_1 in services){
            this[name_1] = this._defineService(services[name_1], endpoint);
        }
    };
    Client.prototype._initializeOptions = function(options) {
        this.streamAllowed = options.stream;
        this.returnSaxStream = options.returnSaxStream;
        this.normalizeNames = options.normalizeNames;
        this.overridePromiseSuffix = options.overridePromiseSuffix || 'Async';
        this.wsdl.options.attributesKey = options.attributesKey || 'attributes';
        this.wsdl.options.envelopeKey = options.envelopeKey || 'soap';
        this.wsdl.options.preserveWhitespace = !!options.preserveWhitespace;
        var igNs = options.ignoredNamespaces;
        if (igNs !== undefined && typeof igNs === 'object') {
            if ('override' in igNs) {
                if (igNs.override === true) {
                    if (igNs.namespaces !== undefined) {
                        this.wsdl.options.ignoredNamespaces = igNs.namespaces;
                    }
                }
            }
        }
        if (options.overrideRootElement !== undefined) {
            this.wsdl.options.overrideRootElement = options.overrideRootElement;
        }
        this.wsdl.options.forceSoap12Headers = !!options.forceSoap12Headers;
    };
    Client.prototype._defineService = function(service, endpoint) {
        var ports = service.ports;
        var def = {};
        for(var name_2 in ports){
            def[name_2] = this._definePort(ports[name_2], endpoint ? endpoint : ports[name_2].location);
        }
        return def;
    };
    Client.prototype._definePort = function(port, endpoint) {
        var location = endpoint;
        var binding = port.binding;
        var methods = binding.methods;
        var def = {};
        for(var name_3 in methods){
            def[name_3] = this._defineMethod(methods[name_3], location);
            var methodName = this.normalizeNames ? name_3.replace(nonIdentifierChars, '_') : name_3;
            this[methodName] = def[name_3];
            if (!nonIdentifierChars.test(methodName)) {
                var suffix = this.overridePromiseSuffix;
                this[methodName + suffix] = this._promisifyMethod(def[name_3]);
            }
        }
        return def;
    };
    Client.prototype._promisifyMethod = function(method) {
        return function(args, options, extraHeaders) {
            return new Promise(function(resolve, reject) {
                var callback = function(err, result, rawResponse, soapHeader, rawRequest, mtomAttachments) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve([
                            result,
                            rawResponse,
                            soapHeader,
                            rawRequest,
                            mtomAttachments
                        ]);
                    }
                };
                method(args, callback, options, extraHeaders);
            });
        };
    };
    Client.prototype._defineMethod = function(method, location) {
        var _this_1 = this;
        var temp;
        return function(args, callback, options, extraHeaders) {
            if (typeof args === 'function') {
                callback = args;
                args = {};
            } else if (typeof options === 'function') {
                temp = callback;
                callback = options;
                options = temp;
            } else if (typeof extraHeaders === 'function') {
                temp = callback;
                callback = extraHeaders;
                extraHeaders = options;
                options = temp;
            }
            _this_1._invoke(method, args, location, function(error, result, rawResponse, soapHeader, rawRequest, mtomAttachments) {
                callback(error, result, rawResponse, soapHeader, rawRequest, mtomAttachments);
            }, options, extraHeaders);
        };
    };
    Client.prototype._processSoapHeader = function(soapHeader, name, namespace, xmlns) {
        switch(typeof soapHeader){
            case 'object':
                return this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);
            case 'function':
                var _this_2 = this;
                // arrow function does not support arguments variable
                // tslint:disable-next-line
                return function() {
                    var result = soapHeader.apply(null, arguments);
                    if (typeof result === 'object') {
                        return _this_2.wsdl.objectToXML(result, name, namespace, xmlns, true);
                    } else {
                        return result;
                    }
                };
            default:
                return soapHeader;
        }
    };
    Client.prototype._invoke = function(method, args, location, callback, options, extraHeaders) {
        var _this_1 = this;
        var name = method.$name;
        var input = method.input;
        var output = method.output;
        var style = method.style;
        var defs = this.wsdl.definitions;
        var envelopeKey = this.wsdl.options.envelopeKey;
        var ns = defs.$targetNamespace;
        var encoding = '';
        var message = '';
        var xml = null;
        var soapAction;
        var alias = utils_1.findPrefix(defs.xmlns, ns);
        var headers = {
            'Content-Type': 'text/xml; charset=utf-8'
        };
        var xmlnsSoap = 'xmlns:' + envelopeKey + '="http://schemas.xmlsoap.org/soap/envelope/"';
        var finish = function(obj, body, response) {
            var result;
            if (!output) {
                // one-way, no output expected
                return callback(null, null, body, obj.Header, xml, response.mtomResponseAttachments);
            }
            // If it's not HTML and Soap Body is empty
            if (!obj.html && !obj.Body) {
                if (response.status >= 400) {
                    var error = new Error('Error http status codes');
                    error.response = response;
                    error.body = body;
                    _this_1.emit('soapError', error, eid);
                    return callback(error, obj, body, obj.Header);
                }
                return callback(null, obj, body, obj.Header);
            }
            if (typeof obj.Body !== 'object') {
                var error = new Error('Cannot parse response');
                error.response = response;
                error.body = body;
                return callback(error, obj, body, undefined, xml);
            }
            result = obj.Body[output.$name];
            // RPC/literal response body may contain elements with added suffixes I.E.
            // 'Response', or 'Output', or 'Out'
            // This doesn't necessarily equal the ouput message name. See WSDL 1.1 Section 2.4.5
            if (!result) {
                result = obj.Body[output.$name.replace(/(?:Out(?:put)?|Response)$/, '')];
            }
            if (!result) {
                [
                    'Response',
                    'Out',
                    'Output'
                ].forEach(function(term) {
                    if (obj.Body.hasOwnProperty(name + term)) {
                        return result = obj.Body[name + term];
                    }
                });
            }
            callback(null, result, body, obj.Header, xml, response.mtomResponseAttachments);
        };
        var parseSync = function(body, response) {
            var obj;
            try {
                obj = _this_1.wsdl.xmlToObject(body);
            } catch (error) {
                //  When the output element cannot be looked up in the wsdl and the body is JSON
                //  instead of sending the error, we pass the body in the response.
                if (!output || !output.$lookupTypes) {
                    debug('Response element is not present. Unable to convert response xml to json.');
                    //  If the response is JSON then return it as-is.
                    var json = _.isObject(body) ? body : tryJSONparse(body);
                    if (json) {
                        return callback(null, response, json, undefined, xml);
                    }
                }
                error.response = response;
                error.body = body;
                _this_1.emit('soapError', error, eid);
                return callback(error, response, body, undefined, xml, response.mtomResponseAttachments);
            }
            return finish(obj, body, response);
        };
        if (this.SOAPAction) {
            soapAction = this.SOAPAction;
        } else if (method.soapAction !== undefined && method.soapAction !== null) {
            soapAction = method.soapAction;
        } else {
            soapAction = (ns.lastIndexOf('/') !== ns.length - 1 ? ns + '/' : ns) + name;
        }
        if (this.wsdl.options.forceSoap12Headers) {
            headers['Content-Type'] = "application/soap+xml; charset=utf-8; action=\"" + soapAction + "\"";
            xmlnsSoap = 'xmlns:' + envelopeKey + '="http://www.w3.org/2003/05/soap-envelope"';
        } else {
            headers.SOAPAction = '"' + soapAction + '"';
        }
        options = options || {};
        // Add extra headers
        if (this.httpHeaders === null) {
            headers = {};
        } else {
            for(var header in this.httpHeaders){
                headers[header] = this.httpHeaders[header];
            }
            for(var attr in extraHeaders){
                headers[attr] = extraHeaders[attr];
            }
        }
        // Allow the security object to add headers
        if (this.security && this.security.addHeaders) {
            this.security.addHeaders(headers);
        }
        if (this.security && this.security.addOptions) {
            this.security.addOptions(options);
        }
        if (style === 'rpc' && (input.parts || input.name === 'element' || args === null)) {
            assert.ok(!style || style === 'rpc', 'invalid message definition for document style binding');
            message = this.wsdl.objectToRpcXML(name, args, alias, ns, input.name !== 'element');
            method.inputSoap === 'encoded' && (encoding = 'soap:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" ');
        } else {
            assert.ok(!style || style === 'document', 'invalid message definition for rpc style binding');
            // pass `input.$lookupType` if `input.$type` could not be found
            message = this.wsdl.objectToDocumentXML(input.$name, args, input.targetNSAlias, input.targetNamespace, input.$type || input.$lookupType);
        }
        var decodedHeaders;
        if (this.soapHeaders) {
            decodedHeaders = this.soapHeaders.map(function(header) {
                if (typeof header === 'function') {
                    return header(method, location, soapAction, args);
                } else {
                    return header;
                }
            }).join(' ');
        }
        xml = '<?xml version="1.0" encoding="utf-8"?>' + '<' + envelopeKey + ':Envelope ' + xmlnsSoap + ' ' + 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' + encoding + this.wsdl.xmlnsInEnvelope + '>' + (decodedHeaders || this.security ? '<' + envelopeKey + ':Header' + (this.wsdl.xmlnsInHeader ? ' ' + this.wsdl.xmlnsInHeader : '') + '>' + (decodedHeaders ? decodedHeaders : '') + (this.security && !this.security.postProcess ? this.security.toXML() : '') + '</' + envelopeKey + ':Header>' : '') + '<' + envelopeKey + ':Body' + (this.bodyAttributes ? this.bodyAttributes.join(' ') : '') + (this.security && this.security.postProcess ? ' Id="_0"' : '') + '>' + message + '</' + envelopeKey + ':Body>' + '</' + envelopeKey + ':Envelope>';
        if (this.security && this.security.postProcess) {
            xml = this.security.postProcess(xml, envelopeKey);
        }
        if (options && options.postProcess) {
            xml = options.postProcess(xml);
        }
        this.lastMessage = message;
        this.lastRequest = xml;
        this.lastEndpoint = location;
        var eid = options.exchangeId || uuid_1.v4();
        this.emit('message', message, eid);
        this.emit('request', xml, eid);
        var tryJSONparse = function(body) {
            try {
                return JSON.parse(body);
            } catch (err) {
                return undefined;
            }
        };
        if (this.streamAllowed && typeof this.httpClient.requestStream === 'function') {
            callback = _.once(callback);
            var startTime_1 = Date.now();
            var onError_1 = function(err) {
                _this_1.lastResponse = null;
                _this_1.lastResponseHeaders = null;
                _this_1.lastElapsedTime = null;
                _this_1.lastRequestHeaders = err.config && err.config.headers;
                _this_1.emit('response', null, null, eid);
                if (_this_1.returnSaxStream || !err.response || !err.response.data) {
                    callback(err, undefined, undefined, undefined, xml);
                } else {
                    err.response.data.on('close', function(e) {
                        callback(err, undefined, undefined, undefined, xml);
                    });
                    err.response.data.on('data', function(e) {
                        err.response.data = e.toString();
                    });
                }
            };
            this.httpClient.requestStream(location, xml, headers, options, this).then(function(res) {
                _this_1.lastRequestHeaders = res.headers;
                if (res.data.on) {
                    res.data.on('error', function(err) {
                        return onError_1(err);
                    });
                }
                // When the output element cannot be looked up in the wsdl,
                // play it safe and don't stream
                if (res.status !== 200 || !output || !output.$lookupTypes) {
                    getStream(res.data).then(function(body) {
                        _this_1.lastResponse = body;
                        _this_1.lastElapsedTime = Date.now() - startTime_1;
                        _this_1.lastResponseHeaders = res && res.headers;
                        // Added mostly for testability, but possibly useful for debugging
                        _this_1.lastRequestHeaders = res.config && res.config.headers || res.headers;
                        _this_1.emit('response', body, res, eid);
                        return parseSync(body, res);
                    });
                    return;
                }
                if (_this_1.returnSaxStream) {
                    // directly return the saxStream allowing the end user to define
                    // the parsing logics and corresponding errors managements
                    var saxStream = _this_1.wsdl.getSaxStream(res.data);
                    return finish({
                        saxStream: saxStream
                    }, '<stream>', res.data);
                } else {
                    _this_1.wsdl.xmlToObject(res.data, function(error, obj) {
                        _this_1.lastResponse = res;
                        _this_1.lastElapsedTime = Date.now() - startTime_1;
                        _this_1.lastResponseHeaders = res && res.headers;
                        // Added mostly for testability, but possibly useful for debugging
                        _this_1.lastRequestHeaders = res.config.headers;
                        _this_1.emit('response', '<stream>', res.data, eid);
                        if (error) {
                            error.response = res;
                            error.body = '<stream>';
                            _this_1.emit('soapError', error, eid);
                            return callback(error, res, undefined, undefined, xml);
                        }
                        return finish(obj, '<stream>', res);
                    });
                }
            }, onError_1);
            return;
        }
        var startTime = Date.now();
        return this.httpClient.request(location, xml, function(err, response, body) {
            _this_1.lastResponse = body;
            if (response) {
                _this_1.lastResponseHeaders = response.headers;
                _this_1.lastElapsedTime = Date.now() - startTime;
                _this_1.lastResponseAttachments = response.mtomResponseAttachments;
                // Added mostly for testability, but possibly useful for debugging
                _this_1.lastRequestHeaders = response.config && response.config.headers;
            }
            _this_1.emit('response', body, response, eid);
            if (err) {
                _this_1.lastRequestHeaders = err.config && err.config.headers;
                try {
                    if (err.response && err.response.data) {
                        _this_1.wsdl.xmlToObject(err.response.data);
                    }
                } catch (error) {
                    err.root = error.root || error;
                }
                callback(err, undefined, undefined, undefined, xml);
            } else {
                return parseSync(body, response);
            }
        }, headers, options, this);
    };
    return Client;
}(events_1.EventEmitter);
exports.Client = Client; //# sourceMappingURL=client.js.map
}),
"[project]/node_modules/soap/lib/security/BasicAuthSecurity.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.BasicAuthSecurity = void 0;
var _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-rsc] (ecmascript)");
var BasicAuthSecurity = function() {
    function BasicAuthSecurity(username, password, defaults) {
        this._username = username;
        this._password = password;
        this.defaults = {};
        _.merge(this.defaults, defaults);
    }
    BasicAuthSecurity.prototype.addHeaders = function(headers) {
        headers.Authorization = 'Basic ' + Buffer.from(this._username + ':' + this._password || '').toString('base64');
    };
    BasicAuthSecurity.prototype.toXML = function() {
        return '';
    };
    BasicAuthSecurity.prototype.addOptions = function(options) {
        _.merge(options, this.defaults);
    };
    return BasicAuthSecurity;
}();
exports.BasicAuthSecurity = BasicAuthSecurity; //# sourceMappingURL=BasicAuthSecurity.js.map
}),
"[project]/node_modules/soap/lib/security/BearerSecurity.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.BearerSecurity = void 0;
var _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-rsc] (ecmascript)");
var BearerSecurity = function() {
    function BearerSecurity(token, defaults) {
        this._token = token;
        this.defaults = {};
        _.merge(this.defaults, defaults);
    }
    BearerSecurity.prototype.addHeaders = function(headers) {
        headers.Authorization = 'Bearer ' + this._token;
    };
    BearerSecurity.prototype.toXML = function() {
        return '';
    };
    BearerSecurity.prototype.addOptions = function(options) {
        _.merge(options, this.defaults);
    };
    return BearerSecurity;
}();
exports.BearerSecurity = BearerSecurity; //# sourceMappingURL=BearerSecurity.js.map
}),
"[project]/node_modules/soap/lib/security/ClientSSLSecurity.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.ClientSSLSecurity = void 0;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-rsc] (ecmascript)");
/**
 * activates SSL for an already existing client
 *
 * @module ClientSSLSecurity
 * @param {Buffer|String}   key
 * @param {Buffer|String}   cert
 * @param {Buffer|String|Array}   [ca]
 * @param {Object}          [defaults]
 * @constructor
 */ var ClientSSLSecurity = function() {
    function ClientSSLSecurity(key, cert, ca, defaults) {
        if (key) {
            if (Buffer.isBuffer(key)) {
                this.key = key;
            } else if (typeof key === 'string') {
                this.key = fs.readFileSync(key);
            } else {
                throw new Error('key should be a buffer or a string!');
            }
        }
        if (cert) {
            if (Buffer.isBuffer(cert)) {
                this.cert = cert;
            } else if (typeof cert === 'string') {
                this.cert = fs.readFileSync(cert);
            } else {
                throw new Error('cert should be a buffer or a string!');
            }
        }
        if (ca) {
            if (Buffer.isBuffer(ca) || Array.isArray(ca)) {
                this.ca = ca;
            } else if (typeof ca === 'string') {
                this.ca = fs.readFileSync(ca);
            } else {
                defaults = ca;
                this.ca = null;
            }
        }
        this.defaults = {};
        _.merge(this.defaults, defaults);
        this.agent = null;
    }
    ClientSSLSecurity.prototype.toXML = function() {
        return '';
    };
    ClientSSLSecurity.prototype.addOptions = function(options) {
        var httpsAgent = null;
        options.key = this.key;
        options.cert = this.cert;
        options.ca = this.ca;
        _.merge(options, this.defaults);
        if (!!options.forever) {
            if (!this.agent) {
                options.keepAlive = true;
                this.agent = new https.Agent(options);
            }
            httpsAgent = this.agent;
        } else {
            httpsAgent = new https.Agent(options);
        }
        options.httpsAgent = httpsAgent;
    };
    return ClientSSLSecurity;
}();
exports.ClientSSLSecurity = ClientSSLSecurity; //# sourceMappingURL=ClientSSLSecurity.js.map
}),
"[project]/node_modules/soap/lib/security/ClientSSLSecurityPFX.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.ClientSSLSecurityPFX = void 0;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-rsc] (ecmascript)");
/**
 * activates SSL for an already existing client using a PFX cert
 *
 * @module ClientSSLSecurityPFX
 * @param {Buffer|String}   pfx
 * @param {String}   passphrase
 * @constructor
 */ var ClientSSLSecurityPFX = function() {
    function ClientSSLSecurityPFX(pfx, passphrase, defaults) {
        if (typeof passphrase === 'object') {
            defaults = passphrase;
        }
        if (pfx) {
            if (Buffer.isBuffer(pfx)) {
                this.pfx = pfx;
            } else if (typeof pfx === 'string') {
                this.pfx = fs.readFileSync(pfx);
            } else {
                throw new Error('supplied pfx file should be a buffer or a file location');
            }
        }
        if (passphrase) {
            if (typeof passphrase === 'string') {
                this.passphrase = passphrase;
            }
        }
        this.defaults = {};
        _.merge(this.defaults, defaults);
    }
    ClientSSLSecurityPFX.prototype.toXML = function() {
        return '';
    };
    ClientSSLSecurityPFX.prototype.addOptions = function(options) {
        options.pfx = this.pfx;
        if (this.passphrase) {
            options.passphrase = this.passphrase;
        }
        _.merge(options, this.defaults);
        options.httpsAgent = new https.Agent(options);
    };
    return ClientSSLSecurityPFX;
}();
exports.ClientSSLSecurityPFX = ClientSSLSecurityPFX; //# sourceMappingURL=ClientSSLSecurityPFX.js.map
}),
"[project]/node_modules/soap/lib/security/NTLMSecurity.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.NTLMSecurity = void 0;
var _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-rsc] (ecmascript)");
var NTLMSecurity = function() {
    function NTLMSecurity(username, password, domain, workstation) {
        if (typeof username === 'object') {
            this.defaults = username;
            this.defaults.ntlm = true;
        } else {
            this.defaults = {
                ntlm: true,
                username: username,
                password: password,
                domain: domain,
                workstation: workstation
            };
        }
    }
    NTLMSecurity.prototype.addHeaders = function(headers) {
        headers.Connection = 'keep-alive';
    };
    NTLMSecurity.prototype.toXML = function() {
        return '';
    };
    NTLMSecurity.prototype.addOptions = function(options) {
        _.merge(options, this.defaults);
    };
    return NTLMSecurity;
}();
exports.NTLMSecurity = NTLMSecurity; //# sourceMappingURL=NTLMSecurity.js.map
}),
"[project]/node_modules/soap/lib/security/WSSecurity.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.WSSecurity = void 0;
var crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/utils.js [app-rsc] (ecmascript)");
var validPasswordTypes = [
    'PasswordDigest',
    'PasswordText'
];
var WSSecurity = function() {
    function WSSecurity(username, password, options) {
        options = options || {};
        this._username = username;
        this._password = password;
        this._envelopeKey = 'soap';
        // must account for backward compatibility for passwordType String param as well as object options defaults: passwordType = 'PasswordText', hasTimeStamp = true
        if (typeof options === 'string') {
            this._passwordType = options ? options : 'PasswordText';
            options = {};
        } else {
            this._passwordType = options.passwordType ? options.passwordType : 'PasswordText';
        }
        if (validPasswordTypes.indexOf(this._passwordType) === -1) {
            this._passwordType = 'PasswordText';
        }
        this._hasTimeStamp = options.hasTimeStamp || typeof options.hasTimeStamp === 'boolean' ? !!options.hasTimeStamp : true;
        /*jshint eqnull:true */ if (options.hasNonce != null) {
            this._hasNonce = !!options.hasNonce;
        }
        this._hasTokenCreated = options.hasTokenCreated || typeof options.hasTokenCreated === 'boolean' ? !!options.hasTokenCreated : true;
        if (options.actor != null) {
            this._actor = options.actor;
        }
        if (options.mustUnderstand != null) {
            this._mustUnderstand = !!options.mustUnderstand;
        }
        if (options.envelopeKey) {
            this._envelopeKey = options.envelopeKey;
        }
    }
    WSSecurity.prototype.toXML = function() {
        // avoid dependency on date formatting libraries
        function getDate(d) {
            function pad(n) {
                return n < 10 ? '0' + n : n;
            }
            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + 'Z';
        }
        var now = new Date();
        var created = getDate(now);
        var timeStampXml = '';
        if (this._hasTimeStamp) {
            var expires = getDate(new Date(now.getTime() + 1000 * 600));
            timeStampXml = '<wsu:Timestamp wsu:Id="Timestamp-' + created + '">' + '<wsu:Created>' + created + '</wsu:Created>' + '<wsu:Expires>' + expires + '</wsu:Expires>' + '</wsu:Timestamp>';
        }
        var password;
        var nonce;
        if (this._hasNonce || this._passwordType !== 'PasswordText') {
            // nonce = base64 ( sha1 ( created + random ) )
            var nHash = crypto.createHash('sha1');
            nHash.update(created + Math.random());
            nonce = nHash.digest('base64');
        }
        if (this._passwordType === 'PasswordText') {
            password = '<wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText">' + utils_1.xmlEscape(this._password) + '</wsse:Password>';
            if (nonce) {
                password += '<wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">' + nonce + '</wsse:Nonce>';
            }
        } else {
            /* Specific Testcase for passwordDigest calculation cover this code
            /* istanbul ignore next */ password = '<wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest">' + utils_1.passwordDigest(nonce, created, this._password) + '</wsse:Password>' + '<wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">' + nonce + '</wsse:Nonce>';
        }
        return '<wsse:Security ' + (this._actor ? this._envelopeKey + ":actor=\"" + this._actor + "\" " : '') + (this._mustUnderstand ? this._envelopeKey + ":mustUnderstand=\"1\" " : '') + 'xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">' + timeStampXml + '<wsse:UsernameToken xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="SecurityToken-' + created + '">' + '<wsse:Username>' + utils_1.xmlEscape(this._username) + '</wsse:Username>' + password + (this._hasTokenCreated ? '<wsu:Created>' + created + '</wsu:Created>' : '') + '</wsse:UsernameToken>' + '</wsse:Security>';
    };
    return WSSecurity;
}();
exports.WSSecurity = WSSecurity; //# sourceMappingURL=WSSecurity.js.map
}),
"[project]/node_modules/soap/lib/security/WSSecurityCert.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.WSSecurityCert = void 0;
var uuid_1 = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-rsc] (ecmascript)");
var xml_crypto_1 = __turbopack_context__.r("[project]/node_modules/xml-crypto/index.js [app-rsc] (ecmascript)");
function addMinutes(date, minutes) {
    return new Date(date.getTime() + minutes * 60000);
}
function dateStringForSOAP(date) {
    return date.getUTCFullYear() + '-' + ('0' + (date.getUTCMonth() + 1)).slice(-2) + '-' + ('0' + date.getUTCDate()).slice(-2) + 'T' + ('0' + date.getUTCHours()).slice(-2) + ':' + ('0' + date.getUTCMinutes()).slice(-2) + ':' + ('0' + date.getUTCSeconds()).slice(-2) + 'Z';
}
function generateCreated() {
    return dateStringForSOAP(new Date());
}
function generateExpires() {
    return dateStringForSOAP(addMinutes(new Date(), 10));
}
function insertStr(src, dst, pos) {
    return [
        dst.slice(0, pos),
        src,
        dst.slice(pos)
    ].join('');
}
function generateId() {
    return uuid_1.v4().replace(/-/gm, '');
}
function resolvePlaceholderInReferences(references, bodyXpath) {
    for(var _i = 0, references_1 = references; _i < references_1.length; _i++){
        var ref = references_1[_i];
        if (ref.xpath === bodyXpathPlaceholder) {
            ref.xpath = bodyXpath;
        }
    }
}
var oasisBaseUri = 'http://docs.oasis-open.org/wss/2004/01';
var bodyXpathPlaceholder = '[[bodyXpath]]';
var WSSecurityCert = function() {
    function WSSecurityCert(privatePEM, publicP12PEM, password, options) {
        var _this = this;
        if (options === void 0) {
            options = {};
        }
        this.signerOptions = {};
        this.additionalReferences = [];
        this.publicP12PEM = publicP12PEM.toString().replace('-----BEGIN CERTIFICATE-----', '').replace('-----END CERTIFICATE-----', '').replace(/(\r\n|\n|\r)/gm, '');
        this.signer = new xml_crypto_1.SignedXml();
        if (options.signatureAlgorithm === 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256') {
            this.signer.signatureAlgorithm = options.signatureAlgorithm;
            this.signer.addReference(bodyXpathPlaceholder, [
                'http://www.w3.org/2001/10/xml-exc-c14n#'
            ], 'http://www.w3.org/2001/04/xmlenc#sha256');
        }
        if (options.additionalReferences && options.additionalReferences.length > 0) {
            this.additionalReferences = options.additionalReferences;
        }
        if (options.signerOptions) {
            var signerOptions = options.signerOptions;
            this.signerOptions = signerOptions;
            if (!this.signerOptions.existingPrefixes) {
                this.signerOptions.existingPrefixes = {};
            }
            if (this.signerOptions.existingPrefixes && !this.signerOptions.existingPrefixes.wsse) {
                this.signerOptions.existingPrefixes.wsse = oasisBaseUri + "/oasis-200401-wss-wssecurity-secext-1.0.xsd";
            }
        } else {
            this.signerOptions = {
                existingPrefixes: {
                    wsse: oasisBaseUri + "/oasis-200401-wss-wssecurity-secext-1.0.xsd"
                }
            };
        }
        this.signer.signingKey = {
            key: privatePEM,
            passphrase: password
        };
        this.x509Id = "x509-" + generateId();
        this.hasTimeStamp = typeof options.hasTimeStamp === 'undefined' ? true : !!options.hasTimeStamp;
        this.signatureTransformations = Array.isArray(options.signatureTransformations) ? options.signatureTransformations : [
            'http://www.w3.org/2000/09/xmldsig#enveloped-signature',
            'http://www.w3.org/2001/10/xml-exc-c14n#'
        ];
        this.signer.keyInfoProvider = {};
        this.signer.keyInfoProvider.getKeyInfo = function(key) {
            return "<wsse:SecurityTokenReference>" + ("<wsse:Reference URI=\"#" + _this.x509Id + "\" ValueType=\"" + oasisBaseUri + "/oasis-200401-wss-x509-token-profile-1.0#X509v3\"/>") + "</wsse:SecurityTokenReference>";
        };
    }
    WSSecurityCert.prototype.postProcess = function(xml, envelopeKey) {
        this.created = generateCreated();
        this.expires = generateExpires();
        var timestampStr = '';
        if (this.hasTimeStamp) {
            timestampStr = "<Timestamp xmlns=\"" + oasisBaseUri + "/oasis-200401-wss-wssecurity-utility-1.0.xsd\" Id=\"_1\">" + ("<Created>" + this.created + "</Created>") + ("<Expires>" + this.expires + "</Expires>") + "</Timestamp>";
        }
        var secHeader = "<wsse:Security xmlns:wsse=\"" + oasisBaseUri + "/oasis-200401-wss-wssecurity-secext-1.0.xsd\" " + ("xmlns:wsu=\"" + oasisBaseUri + "/oasis-200401-wss-wssecurity-utility-1.0.xsd\" ") + (envelopeKey + ":mustUnderstand=\"1\">") + "<wsse:BinarySecurityToken " + ("EncodingType=\"" + oasisBaseUri + "/oasis-200401-wss-soap-message-security-1.0#Base64Binary\" ") + ("ValueType=\"" + oasisBaseUri + "/oasis-200401-wss-x509-token-profile-1.0#X509v3\" ") + ("wsu:Id=\"" + this.x509Id + "\">" + this.publicP12PEM + "</wsse:BinarySecurityToken>") + timestampStr + "</wsse:Security>";
        var xmlWithSec = insertStr(secHeader, xml, xml.indexOf("</" + envelopeKey + ":Header>"));
        var references = this.signatureTransformations;
        var bodyXpath = "//*[name(.)='" + envelopeKey + ":Body']";
        resolvePlaceholderInReferences(this.signer.references, bodyXpath);
        if (!(this.signer.references.filter(function(ref) {
            return ref.xpath === bodyXpath;
        }).length > 0)) {
            this.signer.addReference(bodyXpath, references);
        }
        var _loop_1 = function(name_1) {
            var xpath = "//*[name(.)='" + name_1 + "']";
            if (!(this_1.signer.references.filter(function(ref) {
                return ref.xpath === xpath;
            }).length > 0)) {
                this_1.signer.addReference(xpath, references);
            }
        };
        var this_1 = this;
        for(var _i = 0, _a = this.additionalReferences; _i < _a.length; _i++){
            var name_1 = _a[_i];
            _loop_1(name_1);
        }
        var timestampXpath = "//*[name(.)='wsse:Security']/*[local-name(.)='Timestamp']";
        if (this.hasTimeStamp && !(this.signer.references.filter(function(ref) {
            return ref.xpath === timestampXpath;
        }).length > 0)) {
            this.signer.addReference(timestampXpath, references);
        }
        this.signer.computeSignature(xmlWithSec, this.signerOptions);
        return insertStr(this.signer.getSignatureXml(), xmlWithSec, xmlWithSec.indexOf('</wsse:Security>'));
    };
    return WSSecurityCert;
}();
exports.WSSecurityCert = WSSecurityCert; //# sourceMappingURL=WSSecurityCert.js.map
}),
"[project]/node_modules/soap/lib/security/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);
};
exports.__esModule = true;
__exportStar(__turbopack_context__.r("[project]/node_modules/soap/lib/security/BasicAuthSecurity.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/soap/lib/security/BearerSecurity.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/soap/lib/security/ClientSSLSecurity.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/soap/lib/security/ClientSSLSecurityPFX.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/soap/lib/security/NTLMSecurity.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/soap/lib/security/WSSecurity.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/soap/lib/security/WSSecurityCert.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/soap/lib/server.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>
 * MIT Licensed
 */ var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
exports.__esModule = true;
exports.Server = void 0;
var events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
var url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/utils.js [app-rsc] (ecmascript)");
var zlib;
try {
    zlib = __turbopack_context__.r("[externals]/zlib [external] (zlib, cjs)");
} catch (error) {}
function isExpress(server) {
    return typeof server.route === 'function' && typeof server.use === 'function';
}
function isPromiseLike(obj) {
    return !!obj && typeof obj.then === 'function';
}
function getDateString(d) {
    function pad(n) {
        return n < 10 ? '0' + n : n;
    }
    return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + 'Z';
}
var Server = function(_super) {
    __extends(Server, _super);
    function Server(server, path, services, wsdl, options) {
        var _this_1 = _super.call(this) || this;
        options = options || {
            path: path,
            services: services
        };
        _this_1.path = path;
        _this_1.services = services;
        _this_1.wsdl = wsdl;
        _this_1.suppressStack = options && options.suppressStack;
        _this_1.returnFault = options && options.returnFault;
        _this_1.onewayOptions = options && options.oneWay || {};
        _this_1.enableChunkedEncoding = options.enableChunkedEncoding === undefined ? true : !!options.enableChunkedEncoding;
        _this_1.callback = options.callback ? options.callback : function() {};
        if (typeof path === 'string' && path[path.length - 1] !== '/') {
            path += '/';
        } else if (path instanceof RegExp && path.source[path.source.length - 1] !== '/') {
            path = new RegExp(path.source + '(?:\\/|)');
        }
        wsdl.onReady(function(err) {
            if (isExpress(server)) {
                // handle only the required URL path for express server
                server.route(path).all(function(req, res) {
                    if (typeof _this_1.authorizeConnection === 'function') {
                        if (!_this_1.authorizeConnection(req, res)) {
                            res.end();
                            return;
                        }
                    }
                    _this_1._requestListener(req, res);
                });
                _this_1.callback(err, _this_1);
            } else {
                var listeners_1 = server.listeners('request').slice();
                server.removeAllListeners('request');
                server.addListener('request', function(req, res) {
                    if (typeof _this_1.authorizeConnection === 'function') {
                        if (!_this_1.authorizeConnection(req, res)) {
                            res.end();
                            return;
                        }
                    }
                    var reqPath = url.parse(req.url).pathname;
                    if (reqPath[reqPath.length - 1] !== '/') {
                        reqPath += '/';
                    }
                    if (path === reqPath || path instanceof RegExp && reqPath.match(path)) {
                        _this_1._requestListener(req, res);
                    } else {
                        for(var i = 0, len = listeners_1.length; i < len; i++){
                            listeners_1[i].call(_this_1, req, res);
                        }
                    }
                });
                _this_1.callback(err, _this_1);
            }
        });
        _this_1._initializeOptions(options);
        return _this_1;
    }
    Server.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {
        if (!this.soapHeaders) {
            this.soapHeaders = [];
        }
        soapHeader = this._processSoapHeader(soapHeader, name, namespace, xmlns);
        return this.soapHeaders.push(soapHeader) - 1;
    };
    Server.prototype.changeSoapHeader = function(index, soapHeader, name, namespace, xmlns) {
        if (!this.soapHeaders) {
            this.soapHeaders = [];
        }
        soapHeader = this._processSoapHeader(soapHeader, name, namespace, xmlns);
        this.soapHeaders[index] = soapHeader;
    };
    Server.prototype.getSoapHeaders = function() {
        return this.soapHeaders;
    };
    Server.prototype.clearSoapHeaders = function() {
        this.soapHeaders = null;
    };
    Server.prototype._processSoapHeader = function(soapHeader, name, namespace, xmlns) {
        switch(typeof soapHeader){
            case 'object':
                return this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);
            case 'function':
                var _this_2 = this;
                // arrow function does not support arguments variable
                // tslint:disable-next-line
                return function() {
                    var result = soapHeader.apply(null, arguments);
                    if (typeof result === 'object') {
                        return _this_2.wsdl.objectToXML(result, name, namespace, xmlns, true);
                    } else {
                        return result;
                    }
                };
            default:
                return soapHeader;
        }
    };
    Server.prototype._initializeOptions = function(options) {
        this.wsdl.options.attributesKey = options.attributesKey || 'attributes';
        this.onewayOptions.statusCode = this.onewayOptions.responseCode || 200;
        this.onewayOptions.emptyBody = !!this.onewayOptions.emptyBody;
    };
    Server.prototype._processRequestXml = function(req, res, xml) {
        var _this_1 = this;
        var error;
        try {
            if (typeof this.log === 'function') {
                this.log('received', xml);
            }
            this._process(xml, req, res, function(result, statusCode) {
                _this_1._sendHttpResponse(res, statusCode, result);
                if (typeof _this_1.log === 'function') {
                    _this_1.log('replied', result);
                }
            });
        } catch (err) {
            if (err.Fault !== undefined) {
                return this._sendError(err.Fault, function(result, statusCode) {
                    _this_1._sendHttpResponse(res, statusCode || 500, result);
                    if (typeof _this_1.log === 'function') {
                        _this_1.log('error', err);
                    }
                }, new Date().toISOString());
            } else {
                error = err.stack ? this.suppressStack === true ? err.message : err.stack : err;
                this._sendHttpResponse(res, /* statusCode */ 500, error);
                if (typeof this.log === 'function') {
                    this.log('error', error);
                }
            }
        }
    };
    Server.prototype._requestListener = function(req, res) {
        var _this_1 = this;
        var reqParse = url.parse(req.url);
        var reqPath = reqParse.pathname;
        var reqQuery = reqParse.search;
        if (typeof this.log === 'function') {
            this.log('info', 'Handling ' + req.method + ' on ' + req.url);
        }
        if (req.method === 'GET') {
            if (reqQuery && reqQuery.toLowerCase().startsWith('?wsdl')) {
                if (typeof this.log === 'function') {
                    this.log('info', 'Wants the WSDL');
                }
                res.setHeader('Content-Type', 'application/xml');
                res.write(this.wsdl.toXML());
            }
            res.end();
        } else if (req.method === 'POST') {
            if (typeof req.headers['content-type'] !== 'undefined') {
                res.setHeader('Content-Type', req.headers['content-type']);
            } else {
                res.setHeader('Content-Type', 'application/xml');
            }
            // request body is already provided by an express middleware
            // in this case unzipping should also be done by the express middleware itself
            if (req.body && req.body.length > 0) {
                return this._processRequestXml(req, res, req.body.toString());
            }
            var chunks_1 = [];
            var gunzip = void 0;
            var source = req;
            if (req.headers['content-encoding'] === 'gzip') {
                gunzip = zlib.createGunzip();
                req.pipe(gunzip);
                source = gunzip;
            }
            source.on('data', function(chunk) {
                chunks_1.push(chunk);
            });
            source.on('end', function() {
                var xml = Buffer.concat(chunks_1).toString();
                _this_1._processRequestXml(req, res, xml);
            });
        } else {
            res.end();
        }
    };
    Server.prototype._getSoapAction = function(req) {
        if (typeof req.headers.soapaction === 'undefined') {
            return;
        }
        var soapAction = req.headers.soapaction;
        return soapAction.indexOf('"') === 0 ? soapAction.slice(1, -1) : soapAction;
    };
    Server.prototype._process = function(input, req, res, cb) {
        var _this_1 = this;
        var pathname = url.parse(req.url).pathname.replace(/\/$/, '');
        var obj = this.wsdl.xmlToObject(input);
        var body = obj.Body;
        var headers = obj.Header;
        var binding;
        var methodName;
        var serviceName;
        var portName;
        var includeTimestamp = obj.Header && obj.Header.Security && obj.Header.Security.Timestamp;
        var authenticate = this.authenticate || function defaultAuthenticate() {
            return true;
        };
        var callback = function(result, statusCode) {
            var response = {
                result: result
            };
            _this_1.emit('response', response, methodName);
            cb(response.result, statusCode);
        };
        var process = function() {
            if (typeof _this_1.log === 'function') {
                _this_1.log('info', 'Attempting to bind to ' + pathname);
            }
            // Avoid Cannot convert undefined or null to object due to Object.keys(body)
            // and throw more meaningful error
            if (!body) {
                throw new Error('Failed to parse the SOAP Message body');
            }
            // use port.location and current url to find the right binding
            binding = function() {
                var services = _this_1.wsdl.definitions.services;
                var firstPort;
                var name;
                for(name in services){
                    serviceName = name;
                    var service = services[serviceName];
                    var ports = service.ports;
                    for(name in ports){
                        portName = name;
                        var port = ports[portName];
                        var portPathname = url.parse(port.location).pathname.replace(/\/$/, '');
                        if (typeof _this_1.log === 'function') {
                            _this_1.log('info', 'Trying ' + portName + ' from path ' + portPathname);
                        }
                        if (portPathname === pathname) {
                            return port.binding;
                        }
                        // The port path is almost always wrong for generated WSDLs
                        if (!firstPort) {
                            firstPort = port;
                        }
                    }
                }
                return !firstPort ? void 0 : firstPort.binding;
            }();
            if (!binding) {
                throw new Error('Failed to bind to WSDL');
            }
            try {
                var soapAction = _this_1._getSoapAction(req);
                var messageElemName = Object.keys(body)[0] === 'attributes' ? Object.keys(body)[1] : Object.keys(body)[0];
                var pair = binding.topElements[messageElemName];
                if (soapAction) {
                    methodName = _this_1._getMethodNameBySoapAction(binding, soapAction);
                } else {
                    methodName = pair ? pair.methodName : messageElemName;
                }
                /** Style can be defined in method. If method has no style then look in binding */ var style = binding.methods[methodName].style || binding.style;
                _this_1.emit('request', obj, methodName);
                if (headers) {
                    _this_1.emit('headers', headers, methodName);
                }
                if (style === 'rpc') {
                    _this_1._executeMethod({
                        serviceName: serviceName,
                        portName: portName,
                        methodName: methodName,
                        outputName: messageElemName + 'Response',
                        args: body[messageElemName],
                        headers: headers,
                        style: 'rpc'
                    }, req, res, callback);
                } else {
                    _this_1._executeMethod({
                        serviceName: serviceName,
                        portName: portName,
                        methodName: methodName,
                        outputName: pair.outputName,
                        args: body[messageElemName],
                        headers: headers,
                        style: 'document'
                    }, req, res, callback, includeTimestamp);
                }
            } catch (error) {
                if (error.Fault !== undefined) {
                    return _this_1._sendError(error.Fault, callback, includeTimestamp);
                }
                throw error;
            }
        };
        // Authentication
        if (typeof authenticate === 'function') {
            var authResultProcessed_1 = false;
            var processAuthResult_1 = function(authResult) {
                if (authResultProcessed_1) {
                    return;
                }
                authResultProcessed_1 = true;
                // Handle errors
                if (authResult instanceof Error) {
                    return _this_1._sendError({
                        Code: {
                            Value: 'SOAP-ENV:Server',
                            Subcode: {
                                Value: 'InternalServerError'
                            }
                        },
                        Reason: {
                            Text: authResult.toString()
                        },
                        statusCode: 500
                    }, callback, includeTimestamp);
                }
                // Handle actual results
                if (typeof authResult === 'boolean') {
                    if (authResult === true) {
                        try {
                            process();
                        } catch (error) {
                            if (error.Fault !== undefined) {
                                return _this_1._sendError(error.Fault, callback, includeTimestamp);
                            }
                            return _this_1._sendError({
                                Code: {
                                    Value: 'SOAP-ENV:Server',
                                    Subcode: {
                                        Value: 'InternalServerError'
                                    }
                                },
                                Reason: {
                                    Text: error.toString()
                                },
                                statusCode: 500
                            }, callback, includeTimestamp);
                        }
                    } else {
                        return _this_1._sendError({
                            Code: {
                                Value: 'SOAP-ENV:Client',
                                Subcode: {
                                    Value: 'AuthenticationFailure'
                                }
                            },
                            Reason: {
                                Text: 'Invalid username or password'
                            },
                            statusCode: 401
                        }, callback, includeTimestamp);
                    }
                }
            };
            var functionResult = authenticate(obj.Header && obj.Header.Security, processAuthResult_1, req, obj);
            if (isPromiseLike(functionResult)) {
                functionResult.then(function(result) {
                    processAuthResult_1(result);
                }, function(err) {
                    processAuthResult_1(err);
                });
            }
            if (typeof functionResult === 'boolean') {
                processAuthResult_1(functionResult);
            }
        } else {
            throw new Error('Invalid authenticate function (not a function)');
        }
    };
    Server.prototype._getMethodNameBySoapAction = function(binding, soapAction) {
        for(var methodName in binding.methods){
            if (binding.methods[methodName].soapAction === soapAction) {
                return methodName;
            }
        }
    };
    Server.prototype._executeMethod = function(options, req, res, callback, includeTimestamp) {
        var _this_1 = this;
        options = options || {};
        var method;
        var body;
        var headers;
        var serviceName = options.serviceName;
        var portName = options.portName;
        var binding = this.wsdl.definitions.services[serviceName].ports[portName].binding;
        var methodName = options.methodName;
        var outputName = options.outputName;
        var args = options.args;
        var style = options.style;
        if (this.soapHeaders) {
            headers = this.soapHeaders.map(function(header) {
                if (typeof header === 'function') {
                    return header(methodName, args, options.headers, req, res, _this_1);
                } else {
                    return header;
                }
            }).join('\n');
        }
        try {
            method = this.services[serviceName][portName][methodName];
        } catch (error) {
            return callback(this._envelope('', headers, includeTimestamp));
        }
        var handled = false;
        var handleResult = function(error, result) {
            if (handled) {
                return;
            }
            handled = true;
            if (error) {
                if (error.Fault !== undefined) {
                    return _this_1._sendError(error.Fault, callback, includeTimestamp);
                } else {
                    return _this_1._sendError({
                        Code: {
                            Value: 'SOAP-ENV:Server',
                            Subcode: {
                                Value: 'InternalServerError'
                            }
                        },
                        Reason: {
                            Text: error.toString()
                        },
                        statusCode: 500
                    }, callback, includeTimestamp);
                }
            }
            if (style === 'rpc') {
                body = _this_1.wsdl.objectToRpcXML(outputName, result, '', _this_1.wsdl.definitions.$targetNamespace);
            } else {
                var element = binding.methods[methodName].output;
                body = _this_1.wsdl.objectToDocumentXML(outputName, result, element.targetNSAlias, element.targetNamespace);
            }
            callback(_this_1._envelope(body, headers, includeTimestamp));
        };
        if (!binding.methods[methodName].output) {
            // no output defined = one-way operation so return empty response
            handled = true;
            body = '';
            if (this.onewayOptions.emptyBody) {
                body = this._envelope('', headers, includeTimestamp);
            }
            callback(body, this.onewayOptions.responseCode);
        }
        var methodCallback = function(error, result) {
            if (error && error.Fault !== undefined) {
            // do nothing
            } else if (result === undefined) {
                // Backward compatibility to support one argument callback style
                result = error;
                error = null;
            }
            handleResult(error, result);
        };
        var result = method(args, methodCallback, options.headers, req, res, this);
        if (typeof result !== 'undefined') {
            if (isPromiseLike(result)) {
                result.then(function(value) {
                    handleResult(null, value);
                }, function(err) {
                    handleResult(err);
                });
            } else {
                handleResult(null, result);
            }
        }
    };
    Server.prototype._envelope = function(body, headers, includeTimestamp) {
        var defs = this.wsdl.definitions;
        var ns = defs.$targetNamespace;
        var encoding = '';
        var alias = utils_1.findPrefix(defs.xmlns, ns);
        var envelopeDefinition = this.wsdl.options.forceSoap12Headers ? 'http://www.w3.org/2003/05/soap-envelope' : 'http://schemas.xmlsoap.org/soap/envelope/';
        var xml = '<?xml version="1.0" encoding="utf-8"?>' + '<soap:Envelope xmlns:soap="' + envelopeDefinition + '" ' + encoding + this.wsdl.xmlnsInEnvelope + '>';
        headers = headers || '';
        if (includeTimestamp) {
            var now = new Date();
            var created = getDateString(now);
            var expires = getDateString(new Date(now.getTime() + 1000 * 600));
            headers += '<o:Security soap:mustUnderstand="1" ' + 'xmlns:o="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" ' + 'xmlns:u="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">' + '    <u:Timestamp u:Id="_0">' + '      <u:Created>' + created + '</u:Created>' + '      <u:Expires>' + expires + '</u:Expires>' + '    </u:Timestamp>' + '  </o:Security>\n';
        }
        if (headers !== '') {
            xml += '<soap:Header>' + headers + '</soap:Header>';
        }
        xml += body ? '<soap:Body>' + body + '</soap:Body>' : '<soap:Body/>';
        xml += '</soap:Envelope>';
        return xml;
    };
    Server.prototype._sendError = function(soapFault, callback, includeTimestamp) {
        var fault;
        var statusCode;
        if (soapFault.statusCode) {
            statusCode = soapFault.statusCode;
            soapFault.statusCode = undefined;
        }
        if ('faultcode' in soapFault) {
            // Soap 1.1 error style
            // Root element will be prependend with the soap NS
            // It must match the NS defined in the Envelope (set by the _envelope method)
            fault = this.wsdl.objectToDocumentXML('soap:Fault', soapFault, undefined);
        } else {
            // Soap 1.2 error style.
            // 3rd param is the NS prepended to all elements
            // It must match the NS defined in the Envelope (set by the _envelope method)
            fault = this.wsdl.objectToDocumentXML('Fault', soapFault, 'soap');
        }
        return callback(this._envelope(fault, '', includeTimestamp), statusCode);
    };
    Server.prototype._sendHttpResponse = function(res, statusCode, result) {
        if (statusCode) {
            res.statusCode = statusCode;
        }
        /*
        * Calling res.write(result) follow by res.end() will cause Node.js to use
        * chunked encoding, while calling res.end(result) directly will cause
        * Node.js to calculate and send Content-Length header. See
        * nodejs/node#26005.
        */ if (this.enableChunkedEncoding) {
            res.write(result);
            res.end();
        } else {
            res.end(result);
        }
    };
    return Server;
}(events_1.EventEmitter);
exports.Server = Server; //# sourceMappingURL=server.js.map
}),
"[project]/node_modules/soap/lib/nscontext.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true;
exports.NamespaceContext = void 0;
/**
 * Scope for XML namespaces
 * @param {NamespaceScope} [parent] Parent scope
 * @returns {NamespaceScope}
 * @constructor
 */ var NamespaceScope = function() {
    function NamespaceScope(parent) {
        this.parent = parent;
        this.namespaces = {};
    }
    /**
     * Look up the namespace URI by prefix
     * @param {String} prefix Namespace prefix
     * @param {Boolean} [localOnly] Search current scope only
     * @returns {String} Namespace URI
     */ NamespaceScope.prototype.getNamespaceURI = function(prefix, localOnly) {
        switch(prefix){
            case 'xml':
                return 'http://www.w3.org/XML/1998/namespace';
            case 'xmlns':
                return 'http://www.w3.org/2000/xmlns/';
            default:
                var nsUri = this.namespaces[prefix];
                /*jshint -W116 */ if (nsUri != null) {
                    return nsUri.uri;
                } else if (!localOnly && this.parent) {
                    return this.parent.getNamespaceURI(prefix);
                } else {
                    return null;
                }
        }
    };
    NamespaceScope.prototype.getNamespaceMapping = function(prefix) {
        switch(prefix){
            case 'xml':
                return {
                    uri: 'http://www.w3.org/XML/1998/namespace',
                    prefix: 'xml',
                    declared: true
                };
            case 'xmlns':
                return {
                    uri: 'http://www.w3.org/2000/xmlns/',
                    prefix: 'xmlns',
                    declared: true
                };
            default:
                var mapping = this.namespaces[prefix];
                /*jshint -W116 */ if (mapping != null) {
                    return mapping;
                } else if (this.parent) {
                    return this.parent.getNamespaceMapping(prefix);
                } else {
                    return null;
                }
        }
    };
    /**
     * Look up the namespace prefix by URI
     * @param {String} nsUri Namespace URI
     * @param {Boolean} [localOnly] Search current scope only
     * @returns {String} Namespace prefix
     */ NamespaceScope.prototype.getPrefix = function(nsUri, localOnly) {
        switch(nsUri){
            case 'http://www.w3.org/XML/1998/namespace':
                return 'xml';
            case 'http://www.w3.org/2000/xmlns/':
                return 'xmlns';
            default:
                for(var p in this.namespaces){
                    if (this.namespaces[p].uri === nsUri) {
                        return p;
                    }
                }
                if (!localOnly && this.parent) {
                    return this.parent.getPrefix(nsUri);
                } else {
                    return null;
                }
        }
    };
    return NamespaceScope;
}();
/**
 * Namespace context that manages hierarchical scopes
 * @returns {NamespaceContext}
 * @constructor
 */ var NamespaceContext = function() {
    function NamespaceContext() {
        this.scopes = [];
        this.pushContext();
        this.prefixCount = 0;
    }
    /**
     * Add a prefix/URI namespace mapping
     * @param {String} prefix Namespace prefix
     * @param {String} nsUri Namespace URI
     * @param {Boolean} [localOnly] Search current scope only
     * @returns {boolean} true if the mapping is added or false if the mapping
     * already exists
     */ NamespaceContext.prototype.addNamespace = function(prefix, nsUri, localOnly) {
        if (this.getNamespaceURI(prefix, localOnly) === nsUri) {
            return false;
        }
        if (this.currentScope) {
            this.currentScope.namespaces[prefix] = {
                uri: nsUri,
                prefix: prefix,
                declared: false
            };
            return true;
        }
        return false;
    };
    /**
     * Push a scope into the context
     * @returns {NamespaceScope} The current scope
     */ NamespaceContext.prototype.pushContext = function() {
        var scope = new NamespaceScope(this.currentScope);
        this.scopes.push(scope);
        this.currentScope = scope;
        return scope;
    };
    /**
     * Pop a scope out of the context
     * @returns {NamespaceScope} The removed scope
     */ NamespaceContext.prototype.popContext = function() {
        var scope = this.scopes.pop();
        if (scope) {
            this.currentScope = scope.parent;
        } else {
            this.currentScope = null;
        }
        return scope;
    };
    /**
     * Look up the namespace URI by prefix
     * @param {String} prefix Namespace prefix
     * @param {Boolean} [localOnly] Search current scope only
     * @returns {String} Namespace URI
     */ NamespaceContext.prototype.getNamespaceURI = function(prefix, localOnly) {
        return this.currentScope && this.currentScope.getNamespaceURI(prefix, localOnly);
    };
    /**
     * Look up the namespace prefix by URI
     * @param {String} nsURI Namespace URI
     * @param {Boolean} [localOnly] Search current scope only
     * @returns {String} Namespace prefix
     */ NamespaceContext.prototype.getPrefix = function(nsUri, localOnly) {
        return this.currentScope && this.currentScope.getPrefix(nsUri, localOnly);
    };
    /**
     * Register a namespace
     * @param {String} nsUri Namespace URI
     * @returns {String} The matching or generated namespace prefix
     */ NamespaceContext.prototype.registerNamespace = function(nsUri) {
        var prefix = this.getPrefix(nsUri);
        if (prefix) {
            // If the namespace has already mapped to a prefix
            return prefix;
        } else {
            // Try to generate a unique namespace
            while(true){
                prefix = 'ns' + ++this.prefixCount;
                if (!this.getNamespaceURI(prefix)) {
                    break;
                }
            }
        }
        this.addNamespace(prefix, nsUri, true);
        return prefix;
    };
    /**
     * Declare a namespace prefix/uri mapping
     * @param {String} prefix Namespace prefix
     * @param {String} nsUri Namespace URI
     * @returns {Boolean} true if the declaration is created
     */ NamespaceContext.prototype.declareNamespace = function(prefix, nsUri) {
        if (this.currentScope) {
            var mapping = this.currentScope.getNamespaceMapping(prefix);
            if (mapping && mapping.uri === nsUri && mapping.declared) {
                return false;
            }
            this.currentScope.namespaces[prefix] = {
                uri: nsUri,
                prefix: prefix,
                declared: true
            };
            return true;
        }
        return false;
    };
    return NamespaceContext;
}();
exports.NamespaceContext = NamespaceContext; //# sourceMappingURL=nscontext.js.map
}),
"[project]/node_modules/soap/lib/wsdl/elements.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
exports.__esModule = true;
exports.ImportElement = exports.IncludeElement = exports.BodyElement = exports.DefinitionsElement = exports.ServiceElement = exports.PortElement = exports.BindingElement = exports.PortTypeElement = exports.OperationElement = exports.TypesElement = exports.SchemaElement = exports.DocumentationElement = exports.MessageElement = exports.AllElement = exports.SequenceElement = exports.SimpleContentElement = exports.ComplexContentElement = exports.ComplexTypeElement = exports.EnumerationElement = exports.ChoiceElement = exports.ExtensionElement = exports.RestrictionElement = exports.SimpleTypeElement = exports.OutputElement = exports.InputElement = exports.AnyElement = exports.ElementElement = exports.Element = void 0;
var assert_1 = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
var debugBuilder = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-rsc] (ecmascript)");
var _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-rsc] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/utils.js [app-rsc] (ecmascript)");
var debug = debugBuilder('node-soap');
var Primitives = {
    string: 1,
    boolean: 1,
    decimal: 1,
    float: 1,
    double: 1,
    anyType: 1,
    byte: 1,
    int: 1,
    long: 1,
    short: 1,
    negativeInteger: 1,
    nonNegativeInteger: 1,
    positiveInteger: 1,
    nonPositiveInteger: 1,
    unsignedByte: 1,
    unsignedInt: 1,
    unsignedLong: 1,
    unsignedShort: 1,
    duration: 0,
    dateTime: 0,
    time: 0,
    date: 0,
    gYearMonth: 0,
    gYear: 0,
    gMonthDay: 0,
    gDay: 0,
    gMonth: 0,
    hexBinary: 0,
    base64Binary: 0,
    anyURI: 0,
    QName: 0,
    NOTATION: 0
};
var Element = function() {
    function Element(nsName, attrs, options, schemaAttrs) {
        this.allowedChildren = {};
        this.children = [];
        var parts = utils_1.splitQName(nsName);
        this.nsName = nsName;
        this.prefix = parts.prefix;
        this.name = parts.name;
        this.children = [];
        this.xmlns = {};
        this.schemaXmlns = {};
        this._initializeOptions(options);
        for(var key in attrs){
            var match = /^xmlns:?(.*)$/.exec(key);
            if (match) {
                this.xmlns[match[1] ? match[1] : utils_1.TNS_PREFIX] = attrs[key];
            } else {
                if (key === 'value') {
                    this[this.valueKey] = attrs[key];
                } else {
                    this['$' + key] = attrs[key];
                }
            }
        }
        for(var schemaKey in schemaAttrs){
            var schemaMatch = /^xmlns:?(.*)$/.exec(schemaKey);
            if (schemaMatch && schemaMatch[1]) {
                this.schemaXmlns[schemaMatch[1]] = schemaAttrs[schemaKey];
            }
        }
        if (this.$targetNamespace !== undefined) {
            // Add targetNamespace to the mapping
            this.xmlns[utils_1.TNS_PREFIX] = this.$targetNamespace;
        }
        this.init();
    }
    Element.prototype.deleteFixedAttrs = function() {
        this.children && this.children.length === 0 && delete this.children;
        this.xmlns && Object.keys(this.xmlns).length === 0 && delete this.xmlns;
        delete this.nsName;
        delete this.prefix;
        delete this.name;
    };
    Element.prototype.startElement = function(stack, nsName, attrs, options, schemaXmlns) {
        if (!this.allowedChildren) {
            return;
        }
        var ChildClass = this.allowedChildren[utils_1.splitQName(nsName).name];
        if (ChildClass) {
            var child = new ChildClass(nsName, attrs, options, schemaXmlns);
            child.init();
            stack.push(child);
        } else {
            this.unexpected(nsName);
        }
    };
    Element.prototype.endElement = function(stack, nsName) {
        if (this.nsName === nsName) {
            if (stack.length < 2) {
                return;
            }
            var parent_1 = stack[stack.length - 2];
            if (this !== stack[0]) {
                _.defaultsDeep(stack[0].xmlns, this.xmlns);
                // delete this.xmlns;
                parent_1.children.push(this);
                parent_1.addChild(this);
            }
            stack.pop();
        }
    };
    Element.prototype.addChild = function(child) {
        return;
    };
    Element.prototype.unexpected = function(name) {
        throw new Error('Found unexpected element (' + name + ') inside ' + this.nsName);
    };
    Element.prototype.description = function(definitions, xmlns) {
        return this.$name || this.name;
    };
    Element.prototype.init = function() {};
    Element.prototype._initializeOptions = function(options) {
        if (options) {
            this.valueKey = options.valueKey || '$value';
            this.xmlKey = options.xmlKey || '$xml';
            this.ignoredNamespaces = options.ignoredNamespaces || [];
        } else {
            this.valueKey = '$value';
            this.xmlKey = '$xml';
            this.ignoredNamespaces = [];
        }
    };
    return Element;
}();
exports.Element = Element;
var ElementElement = function(_super) {
    __extends(ElementElement, _super);
    function ElementElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'annotation',
            'complexType',
            'simpleType'
        ]);
        return _this;
    }
    ElementElement.prototype.description = function(definitions, xmlns) {
        var element = {};
        var name = this.$name;
        // Check minOccurs / maxOccurs attributes to see if this element is a list
        // These are default values for an element
        var minOccurs = 1;
        var maxOccurs = 1;
        if (this.$maxOccurs === 'unbounded') {
            maxOccurs = Infinity;
        } else if (Boolean(this.$maxOccurs)) {
            maxOccurs = parseInt(this.$maxOccurs, 10);
        }
        if (Boolean(this.$minOccurs)) {
            minOccurs = parseInt(this.$minOccurs, 10);
        }
        var isMany = maxOccurs > 1;
        if (isMany) {
            name += '[]';
        }
        if (xmlns && xmlns[utils_1.TNS_PREFIX]) {
            this.$targetNamespace = xmlns[utils_1.TNS_PREFIX];
        }
        var type = this.$type || this.$ref;
        if (type) {
            type = utils_1.splitQName(type);
            var typeName = type.name;
            var ns = xmlns && xmlns[type.prefix] || (definitions.xmlns[type.prefix] !== undefined || definitions.xmlns[this.targetNSAlias] !== undefined) && this.schemaXmlns[type.prefix] || definitions.xmlns[type.prefix];
            var schema = definitions.schemas[ns];
            var typeElement = schema && (this.$type ? schema.complexTypes[typeName] || schema.types[typeName] : schema.elements[typeName]);
            var typeStorage = this.$type ? definitions.descriptions.types : definitions.descriptions.elements;
            if (ns && definitions.schemas[ns]) {
                xmlns = definitions.schemas[ns].xmlns;
            }
            if (typeElement && !(typeName in Primitives)) {
                if (!(typeName in typeStorage)) {
                    var elem_1 = {};
                    typeStorage[typeName] = elem_1;
                    var description_1 = typeElement.description(definitions, xmlns);
                    if (typeof description_1 === 'string') {
                        elem_1 = description_1;
                    } else {
                        Object.keys(description_1).forEach(function(key) {
                            elem_1[key] = description_1[key];
                        });
                    }
                    if (this.$ref) {
                        element = elem_1;
                    } else {
                        element[name] = elem_1;
                    }
                    if (typeof elem_1 === 'object') {
                        elem_1.targetNSAlias = type.prefix;
                        elem_1.targetNamespace = ns;
                    }
                    typeStorage[typeName] = elem_1;
                } else {
                    if (this.$ref) {
                        element = typeStorage[typeName];
                    } else {
                        element[name] = typeStorage[typeName];
                    }
                }
            } else {
                element[name] = this.$type;
            }
        } else {
            var children = this.children;
            element[name] = {};
            for(var _i = 0, children_1 = children; _i < children_1.length; _i++){
                var child = children_1[_i];
                if (child instanceof ComplexTypeElement || child instanceof SimpleTypeElement) {
                    element[name] = child.description(definitions, xmlns);
                }
            }
        }
        return element;
    };
    return ElementElement;
}(Element);
exports.ElementElement = ElementElement;
var AnyElement = function(_super) {
    __extends(AnyElement, _super);
    function AnyElement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AnyElement;
}(Element);
exports.AnyElement = AnyElement;
var InputElement = function(_super) {
    __extends(InputElement, _super);
    function InputElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'body',
            'documentation',
            'header',
            'SecuritySpecRef'
        ]);
        return _this;
    }
    InputElement.prototype.addChild = function(child) {
        if (child instanceof BodyElement) {
            this.use = child.$use;
            if (this.use === 'encoded') {
                this.encodingStyle = child.$encodingStyle;
            }
            this.children.pop();
        }
    };
    return InputElement;
}(Element);
exports.InputElement = InputElement;
var OutputElement = function(_super) {
    __extends(OutputElement, _super);
    function OutputElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'body',
            'documentation',
            'header',
            'SecuritySpecRef'
        ]);
        return _this;
    }
    OutputElement.prototype.addChild = function(child) {
        if (child instanceof BodyElement) {
            this.use = child.$use;
            if (this.use === 'encoded') {
                this.encodingStyle = child.$encodingStyle;
            }
            this.children.pop();
        }
    };
    return OutputElement;
}(Element);
exports.OutputElement = OutputElement;
var SimpleTypeElement = function(_super) {
    __extends(SimpleTypeElement, _super);
    function SimpleTypeElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'restriction'
        ]);
        return _this;
    }
    SimpleTypeElement.prototype.description = function(definitions) {
        for(var _i = 0, _a = this.children; _i < _a.length; _i++){
            var child = _a[_i];
            if (child instanceof RestrictionElement) {
                return [
                    this.$name,
                    child.description()
                ].filter(Boolean).join('|');
            }
        }
        return {};
    };
    return SimpleTypeElement;
}(Element);
exports.SimpleTypeElement = SimpleTypeElement;
var RestrictionElement = function(_super) {
    __extends(RestrictionElement, _super);
    function RestrictionElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'all',
            'choice',
            'enumeration',
            'sequence'
        ]);
        return _this;
    }
    RestrictionElement.prototype.description = function(definitions, xmlns) {
        var children = this.children;
        var desc;
        for(var i = 0, child = void 0; child = children[i]; i++){
            if (child instanceof SequenceElement || child instanceof ChoiceElement) {
                desc = child.description(definitions, xmlns);
                break;
            }
        }
        if (desc && this.$base) {
            var type = utils_1.splitQName(this.$base);
            var typeName = type.name;
            var ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix];
            var schema_1 = definitions.schemas[ns];
            var typeElement_1 = schema_1 && (schema_1.complexTypes[typeName] || schema_1.types[typeName] || schema_1.elements[typeName]);
            desc.getBase = function() {
                return typeElement_1.description(definitions, schema_1.xmlns);
            };
            return desc;
        }
        // then simple element
        var base = this.$base ? this.$base + '|' : '';
        var restrictions = this.children.map(function(child) {
            return child.description();
        }).join(',');
        return [
            this.$base,
            restrictions
        ].filter(Boolean).join('|');
    };
    return RestrictionElement;
}(Element);
exports.RestrictionElement = RestrictionElement;
var ExtensionElement = function(_super) {
    __extends(ExtensionElement, _super);
    function ExtensionElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'all',
            'choice',
            'sequence'
        ]);
        return _this;
    }
    ExtensionElement.prototype.description = function(definitions, xmlns) {
        var desc = {};
        for(var _i = 0, _a = this.children; _i < _a.length; _i++){
            var child = _a[_i];
            if (child instanceof SequenceElement || child instanceof ChoiceElement) {
                desc = child.description(definitions, xmlns);
            }
        }
        if (this.$base) {
            var type = utils_1.splitQName(this.$base);
            var typeName = type.name;
            var ns = xmlns && xmlns[type.prefix] || definitions.xmlns[type.prefix];
            var schema = definitions.schemas[ns];
            if (typeName in Primitives) {
                return this.$base;
            } else {
                var typeElement = schema && (schema.complexTypes[typeName] || schema.types[typeName] || schema.elements[typeName]);
                if (typeElement) {
                    var base = typeElement.description(definitions, schema.xmlns);
                    desc = typeof base === 'string' ? base : _.defaults(base, desc);
                }
            }
        }
        return desc;
    };
    return ExtensionElement;
}(Element);
exports.ExtensionElement = ExtensionElement;
var ChoiceElement = function(_super) {
    __extends(ChoiceElement, _super);
    function ChoiceElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'any',
            'choice',
            'element',
            'sequence'
        ]);
        return _this;
    }
    ChoiceElement.prototype.description = function(definitions, xmlns) {
        var choice = {};
        for(var _i = 0, _a = this.children; _i < _a.length; _i++){
            var child = _a[_i];
            var description = child.description(definitions, xmlns);
            for(var key in description){
                choice[key] = description[key];
            }
        }
        return choice;
    };
    return ChoiceElement;
}(Element);
exports.ChoiceElement = ChoiceElement;
var EnumerationElement = function(_super) {
    __extends(EnumerationElement, _super);
    function EnumerationElement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // no children
    EnumerationElement.prototype.description = function() {
        return this[this.valueKey];
    };
    return EnumerationElement;
}(Element);
exports.EnumerationElement = EnumerationElement;
var ComplexTypeElement = function(_super) {
    __extends(ComplexTypeElement, _super);
    function ComplexTypeElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'all',
            'annotation',
            'choice',
            'complexContent',
            'sequence',
            'simpleContent'
        ]);
        return _this;
    }
    ComplexTypeElement.prototype.description = function(definitions, xmlns) {
        var children = this.children || [];
        for(var _i = 0, children_2 = children; _i < children_2.length; _i++){
            var child = children_2[_i];
            if (child instanceof ChoiceElement || child instanceof SequenceElement || child instanceof AllElement || child instanceof SimpleContentElement || child instanceof ComplexContentElement) {
                return child.description(definitions, xmlns);
            }
        }
        return {};
    };
    return ComplexTypeElement;
}(Element);
exports.ComplexTypeElement = ComplexTypeElement;
var ComplexContentElement = function(_super) {
    __extends(ComplexContentElement, _super);
    function ComplexContentElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'extension'
        ]);
        return _this;
    }
    ComplexContentElement.prototype.description = function(definitions, xmlns) {
        for(var _i = 0, _a = this.children; _i < _a.length; _i++){
            var child = _a[_i];
            if (child instanceof ExtensionElement) {
                return child.description(definitions, xmlns);
            }
        }
        return {};
    };
    return ComplexContentElement;
}(Element);
exports.ComplexContentElement = ComplexContentElement;
var SimpleContentElement = function(_super) {
    __extends(SimpleContentElement, _super);
    function SimpleContentElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'extension'
        ]);
        return _this;
    }
    SimpleContentElement.prototype.description = function(definitions, xmlns) {
        for(var _i = 0, _a = this.children; _i < _a.length; _i++){
            var child = _a[_i];
            if (child instanceof ExtensionElement) {
                return child.description(definitions, xmlns);
            }
        }
        return {};
    };
    return SimpleContentElement;
}(Element);
exports.SimpleContentElement = SimpleContentElement;
var SequenceElement = function(_super) {
    __extends(SequenceElement, _super);
    function SequenceElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'any',
            'choice',
            'element',
            'sequence'
        ]);
        return _this;
    }
    SequenceElement.prototype.description = function(definitions, xmlns) {
        var sequence = {};
        for(var _i = 0, _a = this.children; _i < _a.length; _i++){
            var child = _a[_i];
            if (child instanceof AnyElement) {
                continue;
            }
            var description = child.description(definitions, xmlns);
            for(var key in description){
                sequence[key] = description[key];
            }
        }
        return sequence;
    };
    return SequenceElement;
}(Element);
exports.SequenceElement = SequenceElement;
var AllElement = function(_super) {
    __extends(AllElement, _super);
    function AllElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'choice',
            'element'
        ]);
        return _this;
    }
    AllElement.prototype.description = function(definitions, xmlns) {
        var sequence = {};
        for(var _i = 0, _a = this.children; _i < _a.length; _i++){
            var child = _a[_i];
            if (child instanceof AnyElement) {
                continue;
            }
            var description = child.description(definitions, xmlns);
            for(var key in description){
                sequence[key] = description[key];
            }
        }
        return sequence;
    };
    return AllElement;
}(Element);
exports.AllElement = AllElement;
var MessageElement = function(_super) {
    __extends(MessageElement, _super);
    function MessageElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'part',
            'documentation'
        ]);
        _this.element = null;
        _this.parts = null;
        return _this;
    }
    MessageElement.prototype.postProcess = function(definitions) {
        var part = null;
        var children = this.children || [];
        for(var _i = 0, children_3 = children; _i < children_3.length; _i++){
            var child = children_3[_i];
            if (child.name === 'part') {
                part = child;
                break;
            }
        }
        if (!part) {
            return;
        }
        if (part.$element) {
            var lookupTypes = [];
            delete this.parts;
            var nsName = utils_1.splitQName(part.$element);
            var ns = nsName.prefix;
            var schema = definitions.schemas[definitions.xmlns[ns]];
            this.element = schema.elements[nsName.name];
            if (!this.element) {
                debug(nsName.name + ' is not present in wsdl and cannot be processed correctly.');
                return;
            }
            this.element.targetNSAlias = ns;
            this.element.targetNamespace = definitions.xmlns[ns];
            // set the optional $lookupType to be used within `client#_invoke()` when
            // calling `wsdl#objectToDocumentXML()
            this.element.$lookupType = part.$element;
            var elementChildren = this.element.children;
            // get all nested lookup types (only complex types are followed)
            if (elementChildren.length > 0) {
                for(var _a = 0, elementChildren_1 = elementChildren; _a < elementChildren_1.length; _a++){
                    var child = elementChildren_1[_a];
                    lookupTypes.push(this._getNestedLookupTypeString(child));
                }
            }
            // if nested lookup types where found, prepare them for furter usage
            if (lookupTypes.length > 0) {
                lookupTypes = lookupTypes.join('_').split('_').filter(function removeEmptyLookupTypes(type) {
                    return type !== '^';
                });
                var schemaXmlns = definitions.schemas[this.element.targetNamespace].xmlns;
                for(var i = 0; i < lookupTypes.length; i++){
                    lookupTypes[i] = this._createLookupTypeObject(lookupTypes[i], schemaXmlns);
                }
            }
            this.element.$lookupTypes = lookupTypes;
            if (this.element.$type) {
                var type = utils_1.splitQName(this.element.$type);
                var typeNs = schema.xmlns && schema.xmlns[type.prefix] || definitions.xmlns[type.prefix];
                if (typeNs) {
                    if (type.name in Primitives) {
                    // this.element = this.element.$type;
                    } else {
                        // first check local mapping of ns alias to namespace
                        schema = definitions.schemas[typeNs];
                        var ctype = schema.complexTypes[type.name] || schema.types[type.name] || schema.elements[type.name];
                        if (ctype) {
                            this.parts = ctype.description(definitions, schema.xmlns);
                        }
                    }
                }
            } else {
                var method = this.element.description(definitions, schema.xmlns);
                this.parts = method[nsName.name];
            }
            this.children.splice(0, 1);
        } else {
            // rpc encoding
            this.parts = {};
            delete this.element;
            for(var i = 0; part = this.children[i]; i++){
                if (part.name === 'documentation') {
                    continue;
                }
                assert_1.ok(part.name === 'part', 'Expected part element');
                var nsName = utils_1.splitQName(part.$type);
                var ns = definitions.xmlns[nsName.prefix];
                var type = nsName.name;
                var schemaDefinition = definitions.schemas[ns];
                if (typeof schemaDefinition !== 'undefined') {
                    this.parts[part.$name] = definitions.schemas[ns].types[type] || definitions.schemas[ns].complexTypes[type];
                } else {
                    this.parts[part.$name] = part.$type;
                }
                if (typeof this.parts[part.$name] === 'object') {
                    this.parts[part.$name].prefix = nsName.prefix;
                    this.parts[part.$name].xmlns = ns;
                }
                this.children.splice(i--, 1);
            }
        }
        this.deleteFixedAttrs();
    };
    MessageElement.prototype.description = function(definitions) {
        if (this.element) {
            return this.element && this.element.description(definitions);
        }
        var desc = {};
        desc[this.$name] = this.parts;
        return desc;
    };
    /**
     * Takes a given namespaced String(for example: 'alias:property') and creates a lookupType
     * object for further use in as first (lookup) `parameterTypeObj` within the `objectToXML`
     * method and provides an entry point for the already existing code in `findChildSchemaObject`.
     *
     * @method _createLookupTypeObject
     * @param {String}            nsString          The NS String (for example "alias:type").
     * @param {Object}            xmlns       The fully parsed `wsdl` definitions object (including all schemas).
     * @returns {Object}
     * @private
     */ MessageElement.prototype._createLookupTypeObject = function(nsString, xmlns) {
        var splittedNSString = utils_1.splitQName(nsString);
        var nsAlias = splittedNSString.prefix;
        var splittedName = splittedNSString.name.split('#');
        var type = splittedName[0];
        var name = splittedName[1];
        return {
            $namespace: xmlns[nsAlias],
            $type: nsAlias + ':' + type,
            $name: name
        };
    };
    /**
     * Iterates through the element and every nested child to find any defined `$type`
     * property and returns it in a underscore ('_') separated String (using '^' as default
     * value if no `$type` property was found).
     *
     * @method _getNestedLookupTypeString
     * @param {Object}            element         The element which (probably) contains nested `$type` values.
     * @returns {String}
     * @private
     */ MessageElement.prototype._getNestedLookupTypeString = function(element) {
        var _this = this;
        var resolvedType = '^';
        var excluded = this.ignoredNamespaces.concat('xs'); // do not process $type values wich start with
        if (element.hasOwnProperty('$type') && typeof element.$type === 'string') {
            if (excluded.indexOf(element.$type.split(':')[0]) === -1) {
                resolvedType += '_' + element.$type + '#' + element.$name;
            }
        }
        if (element.children.length > 0) {
            element.children.forEach(function(child) {
                var resolvedChildType = _this._getNestedLookupTypeString(child).replace(/\^_/, '');
                if (resolvedChildType && typeof resolvedChildType === 'string') {
                    resolvedType += '_' + resolvedChildType;
                }
            });
        }
        return resolvedType;
    };
    return MessageElement;
}(Element);
exports.MessageElement = MessageElement;
var DocumentationElement = function(_super) {
    __extends(DocumentationElement, _super);
    function DocumentationElement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DocumentationElement;
}(Element);
exports.DocumentationElement = DocumentationElement;
var SchemaElement = function(_super) {
    __extends(SchemaElement, _super);
    function SchemaElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'complexType',
            'element',
            'import',
            'include',
            'simpleType'
        ]);
        _this.complexTypes = {};
        _this.types = {};
        _this.elements = {};
        _this.includes = [];
        return _this;
    }
    SchemaElement.prototype.merge = function(source) {
        var _this = this;
        assert_1.ok(source instanceof SchemaElement);
        _.merge(this.complexTypes, source.complexTypes);
        _.merge(this.types, source.types);
        _.merge(this.elements, source.elements);
        _.merge(this.xmlns, source.xmlns);
        // Merge attributes from source without overwriting our's
        _.merge(this, _.pickBy(source, function(value, key) {
            return key.startsWith('$') && !_this.hasOwnProperty(key);
        }));
        return this;
    };
    SchemaElement.prototype.addChild = function(child) {
        if (child.$name in Primitives) {
            return;
        }
        if (child instanceof IncludeElement || child instanceof ImportElement) {
            var location_1 = child.$schemaLocation || child.$location;
            if (location_1) {
                this.includes.push({
                    namespace: child.$namespace || child.$targetNamespace || this.$targetNamespace,
                    location: location_1
                });
            }
        } else if (child instanceof ComplexTypeElement) {
            this.complexTypes[child.$name] = child;
        } else if (child instanceof ElementElement) {
            this.elements[child.$name] = child;
        } else if (child instanceof SimpleTypeElement) {
            this.types[child.$name] = child;
        }
        this.children.pop();
    // child.deleteFixedAttrs();
    };
    return SchemaElement;
}(Element);
exports.SchemaElement = SchemaElement;
var TypesElement = function(_super) {
    __extends(TypesElement, _super);
    function TypesElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'documentation',
            'schema'
        ]);
        _this.schemas = {};
        return _this;
    }
    // fix#325
    TypesElement.prototype.addChild = function(child) {
        var _a;
        assert_1.ok(child instanceof SchemaElement);
        var targetNamespace = child.$targetNamespace || ((_a = child.includes[0]) === null || _a === void 0 ? void 0 : _a.namespace);
        if (!this.schemas.hasOwnProperty(targetNamespace)) {
            this.schemas[targetNamespace] = child;
        } else {
            console.error('Target-Namespace "' + targetNamespace + '" already in use by another Schema!');
        }
    };
    return TypesElement;
}(Element);
exports.TypesElement = TypesElement;
var OperationElement = function(_super) {
    __extends(OperationElement, _super);
    function OperationElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'documentation',
            'fault',
            'input',
            'operation',
            'output'
        ]);
        _this.input = null;
        _this.output = null;
        _this.inputSoap = null;
        _this.outputSoap = null;
        _this.style = '';
        _this.soapAction = '';
        return _this;
    }
    OperationElement.prototype.addChild = function(child) {
        if (child instanceof OperationElement) {
            this.soapAction = child.$soapAction || '';
            this.style = child.$style || '';
            this.children.pop();
        }
    };
    OperationElement.prototype.postProcess = function(definitions, tag) {
        var children = this.children;
        for(var i = 0, child = void 0; child = children[i]; i++){
            if (child.name !== 'input' && child.name !== 'output') {
                continue;
            }
            if (tag === 'binding') {
                this[child.name] = child;
                children.splice(i--, 1);
                continue;
            }
            var messageName = utils_1.splitQName(child.$message).name;
            var message = definitions.messages[messageName];
            message.postProcess(definitions);
            if (message.element) {
                definitions.messages[message.element.$name] = message;
                this[child.name] = message.element;
            } else {
                this[child.name] = message;
            }
            children.splice(i--, 1);
        }
        this.deleteFixedAttrs();
    };
    OperationElement.prototype.description = function(definitions) {
        var inputDesc = this.input ? this.input.description(definitions) : null;
        var outputDesc = this.output ? this.output.description(definitions) : null;
        return {
            input: inputDesc && inputDesc[Object.keys(inputDesc)[0]],
            output: outputDesc && outputDesc[Object.keys(outputDesc)[0]]
        };
    };
    return OperationElement;
}(Element);
exports.OperationElement = OperationElement;
var PortTypeElement = function(_super) {
    __extends(PortTypeElement, _super);
    function PortTypeElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'documentation',
            'operation'
        ]);
        _this.methods = {};
        return _this;
    }
    PortTypeElement.prototype.postProcess = function(definitions) {
        var children = this.children;
        if (typeof children === 'undefined') {
            return;
        }
        for(var i = 0, child = void 0; child = children[i]; i++){
            if (child.name !== 'operation') {
                continue;
            }
            child.postProcess(definitions, 'portType');
            this.methods[child.$name] = child;
            children.splice(i--, 1);
        }
        delete this.$name;
        this.deleteFixedAttrs();
    };
    PortTypeElement.prototype.description = function(definitions) {
        var methods = {};
        for(var name_1 in this.methods){
            var method = this.methods[name_1];
            methods[name_1] = method.description(definitions);
        }
        return methods;
    };
    return PortTypeElement;
}(Element);
exports.PortTypeElement = PortTypeElement;
var BindingElement = function(_super) {
    __extends(BindingElement, _super);
    function BindingElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'binding',
            'documentation',
            'operation',
            'SecuritySpec'
        ]);
        _this.transport = '';
        _this.style = '';
        _this.methods = {};
        return _this;
    }
    BindingElement.prototype.addChild = function(child) {
        if (child.name === 'binding') {
            this.transport = child.$transport;
            this.style = child.$style;
            this.children.pop();
        }
    };
    BindingElement.prototype.postProcess = function(definitions) {
        var type = utils_1.splitQName(this.$type).name;
        var portType = definitions.portTypes[type];
        var style = this.style;
        var children = this.children;
        if (portType) {
            portType.postProcess(definitions);
            this.methods = portType.methods;
            for(var i = 0, child = void 0; child = children[i]; i++){
                if (child.name !== 'operation') {
                    continue;
                }
                child.postProcess(definitions, 'binding');
                children.splice(i--, 1);
                child.style || (child.style = style);
                var method = this.methods[child.$name];
                if (method) {
                    method.style = child.style;
                    method.soapAction = child.soapAction;
                    method.inputSoap = child.input || null;
                    method.outputSoap = child.output || null;
                    method.inputSoap && method.inputSoap.deleteFixedAttrs();
                    method.outputSoap && method.outputSoap.deleteFixedAttrs();
                }
            }
        }
        delete this.$name;
        delete this.$type;
        this.deleteFixedAttrs();
    };
    BindingElement.prototype.description = function(definitions) {
        var methods = {};
        for(var name_2 in this.methods){
            var method = this.methods[name_2];
            methods[name_2] = method.description(definitions);
        }
        return methods;
    };
    return BindingElement;
}(Element);
exports.BindingElement = BindingElement;
var PortElement = function(_super) {
    __extends(PortElement, _super);
    function PortElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'address',
            'documentation'
        ]);
        _this.location = null;
        return _this;
    }
    PortElement.prototype.addChild = function(child) {
        if (child.name === 'address' && typeof child.$location !== 'undefined') {
            this.location = child.$location;
        }
    };
    return PortElement;
}(Element);
exports.PortElement = PortElement;
var ServiceElement = function(_super) {
    __extends(ServiceElement, _super);
    function ServiceElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'documentation',
            'port'
        ]);
        _this.ports = {};
        return _this;
    }
    ServiceElement.prototype.postProcess = function(definitions) {
        var children = this.children;
        var bindings = definitions.bindings;
        if (children && children.length > 0) {
            for(var i = 0, child = void 0; child = children[i]; i++){
                if (child.name !== 'port') {
                    continue;
                }
                var bindingName = utils_1.splitQName(child.$binding).name;
                var binding = bindings[bindingName];
                if (binding) {
                    binding.postProcess(definitions);
                    this.ports[child.$name] = {
                        location: child.location,
                        binding: binding
                    };
                    children.splice(i--, 1);
                }
            }
        }
        delete this.$name;
        this.deleteFixedAttrs();
    };
    ServiceElement.prototype.description = function(definitions) {
        var ports = {};
        for(var name_3 in this.ports){
            var port = this.ports[name_3];
            ports[name_3] = port.binding.description(definitions);
        }
        return ports;
    };
    return ServiceElement;
}(Element);
exports.ServiceElement = ServiceElement;
var DefinitionsElement = function(_super) {
    __extends(DefinitionsElement, _super);
    function DefinitionsElement() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allowedChildren = buildAllowedChildren([
            'binding',
            'documentation',
            'import',
            'message',
            'portType',
            'service',
            'types'
        ]);
        _this.messages = {};
        _this.portTypes = {};
        _this.bindings = {};
        _this.services = {};
        _this.schemas = {};
        _this.descriptions = {
            types: {},
            elements: {}
        };
        return _this;
    }
    DefinitionsElement.prototype.init = function() {
        if (this.name !== 'definitions') {
            this.unexpected(this.nsName);
        }
    };
    DefinitionsElement.prototype.addChild = function(child) {
        if (child instanceof TypesElement) {
            // Merge types.schemas into definitions.schemas
            _.merge(this.schemas, child.schemas);
        } else if (child instanceof MessageElement) {
            this.messages[child.$name] = child;
        } else if (child.name === 'import') {
            var schemaElement = new SchemaElement(child.$namespace, {});
            schemaElement.init();
            this.schemas[child.$namespace] = schemaElement;
            this.schemas[child.$namespace].addChild(child);
        } else if (child instanceof PortTypeElement) {
            this.portTypes[child.$name] = child;
        } else if (child instanceof BindingElement) {
            if (child.transport === 'http://schemas.xmlsoap.org/soap/http' || child.transport === 'http://www.w3.org/2003/05/soap/bindings/HTTP/') {
                this.bindings[child.$name] = child;
            }
        } else if (child instanceof ServiceElement) {
            this.services[child.$name] = child;
        } else if (child instanceof DocumentationElement) {}
        this.children.pop();
    };
    return DefinitionsElement;
}(Element);
exports.DefinitionsElement = DefinitionsElement;
var BodyElement = function(_super) {
    __extends(BodyElement, _super);
    function BodyElement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return BodyElement;
}(Element);
exports.BodyElement = BodyElement;
var IncludeElement = function(_super) {
    __extends(IncludeElement, _super);
    function IncludeElement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IncludeElement;
}(Element);
exports.IncludeElement = IncludeElement;
var ImportElement = function(_super) {
    __extends(ImportElement, _super);
    function ImportElement() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ImportElement;
}(Element);
exports.ImportElement = ImportElement;
var ElementTypeMap = {
    // group: [GroupElement, 'element group'],
    all: AllElement,
    any: AnyElement,
    binding: BindingElement,
    body: BodyElement,
    choice: ChoiceElement,
    complexContent: ComplexContentElement,
    complexType: ComplexTypeElement,
    definitions: DefinitionsElement,
    documentation: DocumentationElement,
    element: ElementElement,
    enumeration: EnumerationElement,
    extension: ExtensionElement,
    fault: Element,
    "import": ImportElement,
    include: IncludeElement,
    input: InputElement,
    message: MessageElement,
    operation: OperationElement,
    output: OutputElement,
    port: PortElement,
    portType: PortTypeElement,
    restriction: RestrictionElement,
    schema: SchemaElement,
    sequence: SequenceElement,
    service: ServiceElement,
    simpleContent: SimpleContentElement,
    simpleType: SimpleTypeElement,
    types: TypesElement
};
function buildAllowedChildren(elementList) {
    var rtn = {};
    for(var _i = 0, elementList_1 = elementList; _i < elementList_1.length; _i++){
        var element = elementList_1[_i];
        rtn[element.replace(/^_/, '')] = ElementTypeMap[element] || Element;
    }
    return rtn;
} //# sourceMappingURL=elements.js.map
}),
"[project]/node_modules/soap/lib/wsdl/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>
 * MIT Licensed
 *
 */ /*jshint proto:true*/ exports.__esModule = true;
exports.open_wsdl = exports.WSDL = void 0;
var assert_1 = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
var debugBuilder = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-rsc] (ecmascript)");
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var _ = __turbopack_context__.r("[project]/node_modules/lodash/lodash.js [app-rsc] (ecmascript)");
var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var sax = __turbopack_context__.r("[project]/node_modules/sax/lib/sax.js [app-rsc] (ecmascript)");
var stripBom = __turbopack_context__.r("[project]/node_modules/strip-bom/index.js [app-rsc] (ecmascript)");
var url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var http_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/http.js [app-rsc] (ecmascript)");
var nscontext_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/nscontext.js [app-rsc] (ecmascript)");
var utils_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/utils.js [app-rsc] (ecmascript)");
var elements = __turbopack_context__.r("[project]/node_modules/soap/lib/wsdl/elements.js [app-rsc] (ecmascript)");
var debug = debugBuilder('node-soap');
var XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';
var trimLeft = /^[\s\xA0]+/;
var trimRight = /[\s\xA0]+$/;
function trim(text) {
    return text.replace(trimLeft, '').replace(trimRight, '');
}
function deepMerge(destination, source) {
    return _.mergeWith(destination, source, function(a, b) {
        return Array.isArray(a) ? a.concat(b) : undefined;
    });
}
function appendColon(ns) {
    return ns && ns.charAt(ns.length - 1) !== ':' ? ns + ':' : ns;
}
function noColonNameSpace(ns) {
    return ns && ns.charAt(ns.length - 1) === ':' ? ns.substring(0, ns.length - 1) : ns;
}
var WSDL = function() {
    function WSDL(definition, uri, options) {
        var _this = this;
        this.ignoredNamespaces = [
            'tns',
            'targetNamespace',
            'typedNamespace'
        ];
        this.ignoreBaseNameSpaces = false;
        this.valueKey = '$value';
        this.xmlKey = '$xml';
        var fromFunc;
        this.uri = uri;
        this.callback = function() {};
        this._includesWsdl = [];
        // initialize WSDL cache
        this.WSDL_CACHE = {};
        if (options && options.WSDL_CACHE) {
            this.WSDL_CACHE = options.WSDL_CACHE;
        }
        this._initializeOptions(options);
        if (typeof definition === 'string') {
            definition = stripBom(definition);
            fromFunc = this._fromXML;
        } else if (typeof definition === 'object') {
            fromFunc = this._fromServices;
        } else {
            throw new Error('WSDL constructor takes either an XML string or service definition');
        }
        process.nextTick(function() {
            try {
                fromFunc.call(_this, definition);
            } catch (e) {
                return _this.callback(e);
            }
            _this.processIncludes(function(err) {
                var name;
                if (err) {
                    return _this.callback(err);
                }
                try {
                    _this.definitions.deleteFixedAttrs();
                    var services = _this.services = _this.definitions.services;
                    if (services) {
                        for(name in services){
                            services[name].postProcess(_this.definitions);
                        }
                    }
                    var complexTypes = _this.definitions.complexTypes;
                    if (complexTypes) {
                        for(name in complexTypes){
                            complexTypes[name].deleteFixedAttrs();
                        }
                    }
                    // for document style, for every binding, prepare input message element name to (methodName, output message element name) mapping
                    var bindings = _this.definitions.bindings;
                    for(var bindingName in bindings){
                        var binding = bindings[bindingName];
                        if (typeof binding.style === 'undefined') {
                            binding.style = 'document';
                        }
                        var methods = binding.methods;
                        var topEls = binding.topElements = {};
                        for(var methodName in methods){
                            if ((methods[methodName].style || binding.style) !== 'document') {
                                continue;
                            }
                            if (methods[methodName].input) {
                                var inputName = methods[methodName].input.$name;
                                var outputName = '';
                                if (methods[methodName].output) {
                                    outputName = methods[methodName].output.$name;
                                }
                                topEls[inputName] = {
                                    methodName: methodName,
                                    outputName: outputName
                                };
                            }
                        }
                    }
                    // prepare soap envelope xmlns definition string
                    _this.xmlnsInEnvelope = _this._xmlnsMap();
                    _this.callback(err, _this);
                } catch (e) {
                    _this.callback(e);
                }
            });
        });
    }
    WSDL.prototype.onReady = function(callback) {
        if (callback) {
            this.callback = callback;
        }
    };
    WSDL.prototype.processIncludes = function(callback) {
        var schemas = this.definitions.schemas;
        var includes = [];
        for(var ns in schemas){
            var schema = schemas[ns];
            includes = includes.concat(schema.includes || []);
        }
        this._processNextInclude(includes, callback);
    };
    WSDL.prototype.describeServices = function() {
        var services = {};
        for(var name_1 in this.services){
            var service = this.services[name_1];
            services[name_1] = service.description(this.definitions);
        }
        return services;
    };
    WSDL.prototype.toXML = function() {
        return this.xml || '';
    };
    WSDL.prototype.getSaxStream = function(xml) {
        var saxStream = sax.createStream(true, null);
        xml.pipe(saxStream);
        return saxStream;
    };
    WSDL.prototype.xmlToObject = function(xml, callback) {
        var _this = this;
        var p = typeof callback === 'function' ? {} : sax.parser(true, null);
        var objectName = null;
        var root = {};
        var schema = {
            Envelope: {
                Header: {
                    Security: {
                        UsernameToken: {
                            Username: 'string',
                            Password: 'string'
                        }
                    }
                },
                Body: {
                    Fault: {
                        faultcode: 'string',
                        faultstring: 'string',
                        detail: 'string'
                    }
                }
            }
        };
        var stack = [
            {
                name: null,
                object: root,
                schema: schema
            }
        ];
        var xmlns = {};
        var refs = {};
        var id; // {id:{hrefs:[],obj:}, ...}
        p.onopentag = function(node) {
            var nsName = node.name;
            var attrs = node.attributes;
            var name = utils_1.splitQName(nsName).name;
            var attributeName;
            var top = stack[stack.length - 1];
            var topSchema = top.schema;
            var elementAttributes = {};
            var hasNonXmlnsAttribute = false;
            var hasNilAttribute = false;
            var obj = {};
            var originalName = name;
            if (!objectName && top.name === 'Body' && name !== 'Fault') {
                var message = _this.definitions.messages[name];
                // Support RPC/literal messages where response body contains one element named
                // after the operation + 'Response'. See http://www.w3.org/TR/wsdl#_names
                if (!message) {
                    try {
                        // Determine if this is request or response
                        var isInput = false;
                        var isOutput = false;
                        if (/Response$/.test(name)) {
                            isOutput = true;
                            name = name.replace(/Response$/, '');
                        } else if (/Request$/.test(name)) {
                            isInput = true;
                            name = name.replace(/Request$/, '');
                        } else if (/Solicit$/.test(name)) {
                            isInput = true;
                            name = name.replace(/Solicit$/, '');
                        }
                        // Look up the appropriate message as given in the portType's operations
                        var portTypes = _this.definitions.portTypes;
                        var portTypeNames = Object.keys(portTypes);
                        // Currently this supports only one portType definition.
                        var portType = portTypes[portTypeNames[0]];
                        if (isInput) {
                            name = portType.methods[name].input.$name;
                        } else {
                            name = portType.methods[name].output.$name;
                        }
                        message = _this.definitions.messages[name];
                        // 'cache' this alias to speed future lookups
                        _this.definitions.messages[originalName] = _this.definitions.messages[name];
                    } catch (e) {
                        if (_this.options.returnFault) {
                            p.onerror(e);
                        }
                    }
                }
                topSchema = message.description(_this.definitions);
                objectName = originalName;
            }
            if (attrs.href) {
                id = attrs.href.substr(1);
                if (!refs[id]) {
                    refs[id] = {
                        hrefs: [],
                        obj: null
                    };
                }
                refs[id].hrefs.push({
                    par: top.object,
                    key: name,
                    obj: obj
                });
            }
            if (id = attrs.id) {
                if (!refs[id]) {
                    refs[id] = {
                        hrefs: [],
                        obj: null
                    };
                }
            }
            // Handle element attributes
            for(attributeName in attrs){
                if (/^xmlns:|^xmlns$/.test(attributeName)) {
                    xmlns[utils_1.splitQName(attributeName).name] = attrs[attributeName];
                    continue;
                }
                hasNonXmlnsAttribute = true;
                elementAttributes[attributeName] = attrs[attributeName];
            }
            for(attributeName in elementAttributes){
                var res = utils_1.splitQName(attributeName);
                if (res.name === 'nil' && xmlns[res.prefix] === XSI_URI && elementAttributes[attributeName] && (elementAttributes[attributeName].toLowerCase() === 'true' || elementAttributes[attributeName] === '1')) {
                    hasNilAttribute = true;
                    break;
                }
            }
            if (hasNonXmlnsAttribute) {
                obj[_this.options.attributesKey] = elementAttributes;
            }
            // Pick up the schema for the type specified in element's xsi:type attribute.
            var xsiTypeSchema;
            var xsiType;
            for(var prefix in xmlns){
                if (xmlns[prefix] === XSI_URI && prefix + ":type" in elementAttributes) {
                    xsiType = elementAttributes[prefix + ":type"];
                    break;
                }
            }
            if (xsiType) {
                var type = utils_1.splitQName(xsiType);
                var typeURI = void 0;
                if (type.prefix === utils_1.TNS_PREFIX) {
                    // In case of xsi:type = "MyType"
                    typeURI = xmlns[type.prefix] || xmlns.xmlns;
                } else {
                    typeURI = xmlns[type.prefix];
                }
                var typeDef = _this.findSchemaObject(typeURI, type.name);
                if (typeDef) {
                    xsiTypeSchema = typeDef.description(_this.definitions);
                }
            }
            if (topSchema && topSchema[name + '[]']) {
                name = name + '[]';
            }
            stack.push({
                name: originalName,
                object: obj,
                schema: xsiTypeSchema || topSchema && topSchema[name],
                id: attrs.id,
                nil: hasNilAttribute
            });
        };
        p.onclosetag = function(nsName) {
            var cur = stack.pop();
            var obj = cur.object;
            var top = stack[stack.length - 1];
            var topObject = top.object;
            var topSchema = top.schema;
            var name = utils_1.splitQName(nsName).name;
            if (typeof cur.schema === 'string' && (cur.schema === 'string' || cur.schema.split(':')[1] === 'string')) {
                if (typeof obj === 'object' && Object.keys(obj).length === 0) {
                    obj = cur.object = '';
                }
            }
            if (cur.nil === true) {
                if (_this.options.handleNilAsNull) {
                    obj = null;
                } else {
                    return;
                }
            }
            if (_.isPlainObject(obj) && !Object.keys(obj).length) {
                obj = null;
            }
            if (topSchema && topSchema[name + '[]']) {
                if (!topObject[name]) {
                    topObject[name] = [];
                }
                topObject[name].push(obj);
            } else if (name in topObject) {
                if (!Array.isArray(topObject[name])) {
                    topObject[name] = [
                        topObject[name]
                    ];
                }
                topObject[name].push(obj);
            } else {
                topObject[name] = obj;
            }
            if (cur.id) {
                refs[cur.id].obj = obj;
            }
        };
        p.oncdata = function(text) {
            var originalText = text;
            text = trim(text);
            if (!text.length) {
                return;
            }
            if (/<\?xml[\s\S]+\?>/.test(text)) {
                var top_1 = stack[stack.length - 1];
                var value = _this.xmlToObject(text);
                if (top_1.object[_this.options.attributesKey]) {
                    top_1.object[_this.options.valueKey] = value;
                } else {
                    top_1.object = value;
                }
            } else {
                p.ontext(originalText);
            }
        };
        p.onerror = function(e) {
            p.resume();
            throw {
                Fault: {
                    faultcode: 500,
                    faultstring: 'Invalid XML',
                    detail: new Error(e).message,
                    statusCode: 500
                }
            };
        };
        p.ontext = function(text) {
            var originalText = text;
            text = trim(text);
            if (!text.length) {
                return;
            }
            var top = stack[stack.length - 1];
            var name = utils_1.splitQName(top.schema).name;
            var value;
            if (_this.options && _this.options.customDeserializer && _this.options.customDeserializer[name]) {
                value = _this.options.customDeserializer[name](text, top);
            } else {
                if (name === 'int' || name === 'integer' || name === 'short' || name === 'long') {
                    value = parseInt(text, 10);
                } else if (name === 'double' || name === 'float' || name === 'decimal') {
                    value = Number(text);
                } else if (name === 'bool' || name === 'boolean') {
                    value = text.toLowerCase() === 'true' || text === '1';
                } else if (name === 'dateTime' || name === 'date') {
                    value = new Date(text);
                } else {
                    if (_this.options.preserveWhitespace) {
                        text = originalText;
                    }
                    // handle string or other types
                    if (typeof top.object !== 'string') {
                        value = text;
                    } else {
                        value = top.object + text;
                    }
                }
            }
            if (top.object[_this.options.attributesKey]) {
                top.object[_this.options.valueKey] = value;
            } else {
                top.object = value;
            }
        };
        if (typeof callback === 'function') {
            // we be streaming
            var saxStream = sax.createStream(true, null);
            saxStream.on('opentag', p.onopentag);
            saxStream.on('closetag', p.onclosetag);
            saxStream.on('cdata', p.oncdata);
            saxStream.on('text', p.ontext);
            xml.pipe(saxStream).on('error', function(err) {
                callback(err);
            }).on('end', function() {
                var r;
                try {
                    r = finish();
                } catch (e) {
                    return callback(e);
                }
                callback(null, r);
            });
            return;
        }
        p.write(xml).close();
        return finish();
        //TURBOPACK unreachable
        ;
        function finish() {
            // MultiRef support: merge objects instead of replacing
            for(var n in refs){
                var ref = refs[n];
                for(var _i = 0, _a = ref.hrefs; _i < _a.length; _i++){
                    var href = _a[_i];
                    Object.assign(href.obj, ref.obj);
                }
            }
            if (root.Envelope) {
                var body = root.Envelope.Body;
                if (body && body.Fault) {
                    var code = body.Fault.faultcode && body.Fault.faultcode.$value;
                    var string = body.Fault.faultstring && body.Fault.faultstring.$value;
                    var detail = body.Fault.detail && body.Fault.detail.$value;
                    code = code || body.Fault.faultcode;
                    string = string || body.Fault.faultstring;
                    detail = detail || body.Fault.detail;
                    var error = new Error(code + ': ' + string + (detail ? ': ' + JSON.stringify(detail) : ''));
                    error.root = root;
                    throw error;
                }
                return root.Envelope;
            }
            return root;
        }
    };
    /**
     * Look up a XSD type or element by namespace URI and name
     * @param {String} nsURI Namespace URI
     * @param {String} qname Local or qualified name
     * @returns {*} The XSD type/element definition
     */ WSDL.prototype.findSchemaObject = function(nsURI, qname) {
        if (!nsURI || !qname) {
            return null;
        }
        var def = null;
        if (this.definitions.schemas) {
            var schema = this.definitions.schemas[nsURI];
            if (schema) {
                if (qname.indexOf(':') !== -1) {
                    qname = qname.substring(qname.indexOf(':') + 1, qname.length);
                }
                // if the client passed an input element which has a `$lookupType` property instead of `$type`
                // the `def` is found in `schema.elements`.
                def = schema.complexTypes[qname] || schema.types[qname] || schema.elements[qname];
            }
        }
        return def;
    };
    /**
     * Create document style xml string from the parameters
     * @param {String} name
     * @param {*} params
     * @param {String} nsPrefix
     * @param {String} nsURI
     * @param {String} type
     */ WSDL.prototype.objectToDocumentXML = function(name, params, nsPrefix, nsURI, type) {
        // If user supplies XML already, just use that.  XML Declaration should not be present.
        if (params && params._xml) {
            return params._xml;
        }
        var args = {};
        args[name] = params;
        var parameterTypeObj = type ? this.findSchemaObject(nsURI, type) : null;
        return this.objectToXML(args, null, nsPrefix, nsURI, true, null, parameterTypeObj);
    };
    /**
     * Create RPC style xml string from the parameters
     * @param {String} name
     * @param {*} params
     * @param {String} nsPrefix
     * @param {String} nsURI
     * @returns {string}
     */ WSDL.prototype.objectToRpcXML = function(name, params, nsPrefix, nsURI, isParts) {
        var parts = [];
        var defs = this.definitions;
        var nsAttrName = '_xmlns';
        nsPrefix = nsPrefix || utils_1.findPrefix(defs.xmlns, nsURI);
        nsURI = nsURI || defs.xmlns[nsPrefix];
        nsPrefix = nsPrefix === utils_1.TNS_PREFIX ? '' : nsPrefix + ':';
        parts.push([
            '<',
            nsPrefix,
            name,
            '>'
        ].join(''));
        for(var key in params){
            if (!params.hasOwnProperty(key)) {
                continue;
            }
            if (key !== nsAttrName) {
                var value = params[key];
                var prefixedKey = (isParts ? '' : nsPrefix) + key;
                var attributes = [];
                if (typeof value === 'object' && value.hasOwnProperty(this.options.attributesKey)) {
                    var attrs = value[this.options.attributesKey];
                    for(var n in attrs){
                        attributes.push(' ' + n + '=' + '"' + attrs[n] + '"');
                    }
                }
                parts.push([
                    '<',
                    prefixedKey
                ].concat(attributes).concat('>').join(''));
                parts.push(typeof value === 'object' ? this.objectToXML(value, key, nsPrefix, nsURI) : utils_1.xmlEscape(value));
                parts.push([
                    '</',
                    prefixedKey,
                    '>'
                ].join(''));
            }
        }
        parts.push([
            '</',
            nsPrefix,
            name,
            '>'
        ].join(''));
        return parts.join('');
    };
    WSDL.prototype.isIgnoredNameSpace = function(ns) {
        return this.options.ignoredNamespaces.indexOf(ns) > -1;
    };
    WSDL.prototype.filterOutIgnoredNameSpace = function(ns) {
        var namespace = noColonNameSpace(ns);
        return this.isIgnoredNameSpace(namespace) ? '' : namespace;
    };
    /**
     * Convert an object to XML.  This is a recursive method as it calls itself.
     *
     * @param {Object} obj the object to convert.
     * @param {String} name the name of the element (if the object being traversed is
     * an element).
     * @param {String} nsPrefix the namespace prefix of the object I.E. xsd.
     * @param {String} nsURI the full namespace of the object I.E. http://w3.org/schema.
     * @param {Boolean} isFirst whether or not this is the first item being traversed.
     * @param {?} xmlnsAttr
     * @param {?} parameterTypeObject
     * @param {NamespaceContext} nsContext Namespace context
     */ WSDL.prototype.objectToXML = function(obj, name, nsPrefix, nsURI, isFirst, xmlnsAttr, schemaObject, nsContext) {
        var schema = this.definitions.schemas[nsURI];
        var parentNsPrefix = nsPrefix ? nsPrefix.parent : undefined;
        if (typeof parentNsPrefix !== 'undefined') {
            // we got the parentNsPrefix for our array. setting the namespace-variable back to the current namespace string
            nsPrefix = nsPrefix.current;
        }
        parentNsPrefix = noColonNameSpace(parentNsPrefix);
        if (this.isIgnoredNameSpace(parentNsPrefix)) {
            parentNsPrefix = '';
        }
        var soapHeader = !schema;
        var qualified = schema && schema.$elementFormDefault === 'qualified';
        var parts = [];
        var prefixNamespace = (nsPrefix || qualified) && nsPrefix !== utils_1.TNS_PREFIX;
        var xmlnsAttrib = '';
        if (nsURI && isFirst) {
            if (this.options.overrideRootElement && this.options.overrideRootElement.xmlnsAttributes) {
                this.options.overrideRootElement.xmlnsAttributes.forEach(function(attribute) {
                    xmlnsAttrib += ' ' + attribute.name + '="' + attribute.value + '"';
                });
            } else {
                if (prefixNamespace && !this.isIgnoredNameSpace(nsPrefix)) {
                    // resolve the prefix namespace
                    xmlnsAttrib += ' xmlns:' + nsPrefix + '="' + nsURI + '"';
                }
                // only add default namespace if the schema elementFormDefault is qualified
                if (qualified || soapHeader) {
                    xmlnsAttrib += ' xmlns="' + nsURI + '"';
                }
            }
        }
        if (!nsContext) {
            nsContext = new nscontext_1.NamespaceContext();
            nsContext.declareNamespace(nsPrefix, nsURI);
        } else {
            nsContext.pushContext();
        }
        // explicitly use xmlns attribute if available
        if (xmlnsAttr && !(this.options.overrideRootElement && this.options.overrideRootElement.xmlnsAttributes)) {
            xmlnsAttrib = xmlnsAttr;
        }
        var ns = '';
        if (this.options.overrideRootElement && isFirst) {
            ns = this.options.overrideRootElement.namespace;
        } else if (prefixNamespace && (qualified || isFirst || soapHeader) && !this.isIgnoredNameSpace(nsPrefix)) {
            ns = nsPrefix;
        }
        var i;
        var n;
        // start building out XML string.
        if (Array.isArray(obj)) {
            var nonSubNameSpace = '';
            var emptyNonSubNameSpaceForArray = false;
            var nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);
            if (nameWithNsRegex) {
                nonSubNameSpace = nameWithNsRegex[1];
                name = nameWithNsRegex[2];
            } else if (name[0] === ':') {
                emptyNonSubNameSpaceForArray = true;
                name = name.substr(1);
            }
            for(i = 0, n = obj.length; i < n; i++){
                var item = obj[i];
                var arrayAttr = this.processAttributes(item, nsContext);
                var correctOuterNsPrefix = nonSubNameSpace || parentNsPrefix || ns; // using the parent namespace prefix if given
                var body = this.objectToXML(item, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);
                var openingTagParts = [
                    '<',
                    name,
                    arrayAttr,
                    xmlnsAttrib
                ];
                if (!emptyNonSubNameSpaceForArray) {
                    openingTagParts = [
                        '<',
                        appendColon(correctOuterNsPrefix),
                        name,
                        arrayAttr,
                        xmlnsAttrib
                    ];
                }
                if (body === '' && this.options.useEmptyTag) {
                    // Use empty (self-closing) tags if no contents
                    openingTagParts.push(' />');
                    parts.push(openingTagParts.join(''));
                } else {
                    openingTagParts.push('>');
                    if (this.options.namespaceArrayElements || i === 0) {
                        parts.push(openingTagParts.join(''));
                    }
                    parts.push(body);
                    if (this.options.namespaceArrayElements || i === n - 1) {
                        if (emptyNonSubNameSpaceForArray) {
                            parts.push([
                                '</',
                                name,
                                '>'
                            ].join(''));
                        } else {
                            parts.push([
                                '</',
                                appendColon(correctOuterNsPrefix),
                                name,
                                '>'
                            ].join(''));
                        }
                    }
                }
            }
        } else if (typeof obj === 'object') {
            var currentChildXmlnsAttrib = '';
            for(name in obj){
                // Happens when Object.create(null) is used, it will not inherit the Object prototype
                if (!obj.hasOwnProperty) {
                    obj = Object.assign({}, obj);
                }
                if (!obj.hasOwnProperty(name)) {
                    continue;
                }
                // don't process attributes as element
                if (name === this.options.attributesKey) {
                    continue;
                }
                // Its the value of a xml object. Return it directly.
                if (name === this.options.xmlKey) {
                    nsContext.popContext();
                    return obj[name];
                }
                // Its the value of an item. Return it directly.
                if (name === this.options.valueKey) {
                    nsContext.popContext();
                    return utils_1.xmlEscape(obj[name]);
                }
                var child = obj[name];
                if (typeof child === 'undefined') {
                    continue;
                }
                var attr = this.processAttributes(child, nsContext);
                var value = '';
                var nonSubNameSpace = '';
                var emptyNonSubNameSpace = false;
                var nameWithNsRegex = /^([^:]+):([^:]+)$/.exec(name);
                if (nameWithNsRegex) {
                    nonSubNameSpace = nameWithNsRegex[1] + ':';
                    name = nameWithNsRegex[2];
                } else if (name[0] === ':') {
                    emptyNonSubNameSpace = true;
                    name = name.substr(1);
                }
                if (isFirst) {
                    value = this.objectToXML(child, name, nsPrefix, nsURI, false, null, schemaObject, nsContext);
                } else {
                    if (this.definitions.schemas) {
                        if (schema) {
                            var childSchemaObject = this.findChildSchemaObject(schemaObject, name);
                            // find sub namespace if not a primitive
                            if (childSchemaObject && (childSchemaObject.$type && childSchemaObject.$type.indexOf('xsd:') === -1 || childSchemaObject.$ref || childSchemaObject.$name)) {
                                /*if the base name space of the children is not in the ingoredSchemaNamspaces we use it.
                                 This is because in some services the child nodes do not need the baseNameSpace.
                                 */ var childNsPrefix = '';
                                var childName = '';
                                var childNsURI = void 0;
                                var childXmlnsAttrib = '';
                                var elementQName = childSchemaObject.$ref || childSchemaObject.$name;
                                if (elementQName) {
                                    elementQName = utils_1.splitQName(elementQName);
                                    childName = elementQName.name;
                                    if (elementQName.prefix === utils_1.TNS_PREFIX) {
                                        // Local element
                                        childNsURI = childSchemaObject.$targetNamespace;
                                        childNsPrefix = nsContext.registerNamespace(childNsURI);
                                        if (this.isIgnoredNameSpace(childNsPrefix)) {
                                            childNsPrefix = nsPrefix;
                                        }
                                    } else {
                                        childNsPrefix = elementQName.prefix;
                                        if (this.isIgnoredNameSpace(childNsPrefix)) {
                                            childNsPrefix = nsPrefix;
                                        }
                                        childNsURI = schema.xmlns[childNsPrefix] || this.definitions.xmlns[childNsPrefix];
                                    }
                                    var unqualified = false;
                                    // Check qualification form for local elements
                                    if (childSchemaObject.$name && childSchemaObject.targetNamespace === undefined) {
                                        if (childSchemaObject.$form === 'unqualified') {
                                            unqualified = true;
                                        } else if (childSchemaObject.$form === 'qualified') {
                                            unqualified = false;
                                        } else {
                                            unqualified = schema.$elementFormDefault !== 'qualified';
                                        }
                                    }
                                    if (unqualified) {
                                        childNsPrefix = '';
                                    }
                                    if (childNsURI && childNsPrefix) {
                                        if (nsContext.declareNamespace(childNsPrefix, childNsURI)) {
                                            childXmlnsAttrib = ' xmlns:' + childNsPrefix + '="' + childNsURI + '"';
                                            if (!xmlnsAttrib.includes(childNsPrefix)) {
                                                currentChildXmlnsAttrib = childXmlnsAttrib;
                                                xmlnsAttrib += childXmlnsAttrib;
                                            }
                                        }
                                    }
                                }
                                var resolvedChildSchemaObject = void 0;
                                if (childSchemaObject.$type) {
                                    var typeQName = utils_1.splitQName(childSchemaObject.$type);
                                    var typePrefix = typeQName.prefix;
                                    var typeURI = schema.xmlns[typePrefix] || this.definitions.xmlns[typePrefix];
                                    childNsURI = typeURI;
                                    if (typeURI !== 'http://www.w3.org/2001/XMLSchema' && typePrefix !== utils_1.TNS_PREFIX) {
                                        // Add the prefix/namespace mapping, but not declare it
                                        nsContext.addNamespace(typePrefix, typeURI);
                                    }
                                    resolvedChildSchemaObject = this.findSchemaType(typeQName.name, typeURI) || childSchemaObject;
                                } else {
                                    resolvedChildSchemaObject = this.findSchemaObject(childNsURI, childName) || childSchemaObject;
                                }
                                if (childSchemaObject.$baseNameSpace && this.options.ignoreBaseNameSpaces) {
                                    childNsPrefix = nsPrefix;
                                    childNsURI = nsURI;
                                }
                                if (this.options.ignoreBaseNameSpaces) {
                                    childNsPrefix = '';
                                    childNsURI = '';
                                }
                                ns = childNsPrefix;
                                if (Array.isArray(child)) {
                                    // for arrays, we need to remember the current namespace
                                    childNsPrefix = {
                                        current: childNsPrefix,
                                        parent: ns
                                    };
                                    childXmlnsAttrib = childXmlnsAttrib && childXmlnsAttrib.length ? childXmlnsAttrib : currentChildXmlnsAttrib;
                                } else {
                                    // parent (array) already got the namespace
                                    childXmlnsAttrib = null;
                                }
                                value = this.objectToXML(child, name, childNsPrefix, childNsURI, false, childXmlnsAttrib, resolvedChildSchemaObject, nsContext);
                            } else if (obj[this.options.attributesKey] && obj[this.options.attributesKey].xsi_type) {
                                // if parent object has complex type defined and child not found in parent
                                var completeChildParamTypeObject = this.findChildSchemaObject(obj[this.options.attributesKey].xsi_type.type, obj[this.options.attributesKey].xsi_type.xmlns);
                                nonSubNameSpace = obj[this.options.attributesKey].xsi_type.prefix;
                                nsContext.addNamespace(obj[this.options.attributesKey].xsi_type.prefix, obj[this.options.attributesKey].xsi_type.xmlns);
                                value = this.objectToXML(child, name, obj[this.options.attributesKey].xsi_type.prefix, obj[this.options.attributesKey].xsi_type.xmlns, false, null, null, nsContext);
                            } else {
                                if (Array.isArray(child)) {
                                    if (emptyNonSubNameSpace) {
                                        name = ':' + name;
                                    } else {
                                        name = nonSubNameSpace + name;
                                    }
                                }
                                value = this.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);
                            }
                        } else {
                            value = this.objectToXML(child, name, nsPrefix, nsURI, false, null, null, nsContext);
                        }
                    }
                }
                ns = noColonNameSpace(ns);
                if (prefixNamespace && !qualified && isFirst && !this.options.overrideRootElement) {
                    ns = nsPrefix;
                } else if (this.isIgnoredNameSpace(ns)) {
                    ns = '';
                }
                var useEmptyTag = !value && this.options.useEmptyTag;
                if (!Array.isArray(child)) {
                    // start tag
                    parts.push([
                        '<',
                        emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns),
                        name,
                        attr,
                        xmlnsAttrib,
                        child === null ? ' xsi:nil="true"' : '',
                        useEmptyTag ? ' />' : '>'
                    ].join(''));
                }
                if (!useEmptyTag) {
                    parts.push(value);
                    if (!Array.isArray(child)) {
                        // end tag
                        parts.push([
                            '</',
                            emptyNonSubNameSpace ? '' : appendColon(nonSubNameSpace || ns),
                            name,
                            '>'
                        ].join(''));
                    }
                }
            }
        } else if (obj !== undefined) {
            parts.push(this.options.escapeXML ? utils_1.xmlEscape(obj) : obj);
        }
        nsContext.popContext();
        return parts.join('');
    };
    WSDL.prototype.processAttributes = function(child, nsContext) {
        var attr = '';
        if (child === null || child === undefined) {
            child = [];
        }
        var attrObj = child[this.options.attributesKey] || {};
        if (attrObj && attrObj.xsi_type) {
            var xsiType = attrObj.xsi_type;
            var prefix = xsiType.prefix || xsiType.namespace;
            if (xsiType.xmlns) {
                // Generate a new namespace for complex extension if one not provided
                if (!prefix) {
                    prefix = nsContext.registerNamespace(xsiType.xmlns);
                } else {
                    nsContext.declareNamespace(prefix, xsiType.xmlns);
                }
                xsiType.prefix = prefix;
            }
        }
        Object.keys(attrObj).forEach(function(k) {
            var v = attrObj[k];
            if (k === 'xsi_type') {
                var name_2 = v.type;
                if (v.prefix) {
                    name_2 = v.prefix + ":" + name_2;
                }
                attr += " xsi:type=\"" + name_2 + "\"";
                if (v.xmlns) {
                    attr += " xmlns:" + v.prefix + "=\"" + v.xmlns + "\"";
                }
            } else {
                attr += " " + k + "=\"" + utils_1.xmlEscape(v) + "\"";
            }
        });
        return attr;
    };
    /**
     * Look up a schema type definition
     * @param name
     * @param nsURI
     * @returns {*}
     */ WSDL.prototype.findSchemaType = function(name, nsURI) {
        if (!this.definitions.schemas || !name || !nsURI) {
            return null;
        }
        var schema = this.definitions.schemas[nsURI];
        if (!schema || !schema.complexTypes) {
            return null;
        }
        return schema.complexTypes[name];
    };
    WSDL.prototype.findChildSchemaObject = function(parameterTypeObj, childName, backtrace) {
        if (!parameterTypeObj || !childName) {
            return null;
        }
        if (!backtrace) {
            backtrace = [];
        }
        if (backtrace.indexOf(parameterTypeObj) >= 0) {
            // We've recursed back to ourselves; break.
            return null;
        } else {
            backtrace = backtrace.concat([
                parameterTypeObj
            ]);
        }
        var found = null;
        var i = 0;
        var child;
        var ref;
        if (Array.isArray(parameterTypeObj.$lookupTypes) && parameterTypeObj.$lookupTypes.length) {
            var types = parameterTypeObj.$lookupTypes;
            for(i = 0; i < types.length; i++){
                var typeObj = types[i];
                if (typeObj.$name === childName) {
                    found = typeObj;
                    break;
                }
            }
        }
        var object = parameterTypeObj;
        if (object.$name === childName && object.name === 'element') {
            return object;
        }
        if (object.$ref) {
            ref = utils_1.splitQName(object.$ref);
            if (ref.name === childName) {
                return object;
            }
        }
        var childNsURI;
        // want to avoid unecessary recursion to improve performance
        if (object.$type && backtrace.length === 1) {
            var typeInfo = utils_1.splitQName(object.$type);
            if (typeInfo.prefix === utils_1.TNS_PREFIX) {
                childNsURI = parameterTypeObj.$targetNamespace;
            } else {
                childNsURI = this.definitions.xmlns[typeInfo.prefix];
            }
            var typeDef = this.findSchemaType(typeInfo.name, childNsURI);
            if (typeDef) {
                return this.findChildSchemaObject(typeDef, childName, backtrace);
            }
        }
        // handle $base (e.g. for ExtensionElement) like $type
        if (object.$base && (!Array.isArray(object.children) || !object.children.length)) {
            var baseInfo = utils_1.splitQName(object.$base);
            childNsURI = parameterTypeObj.$targetNamespace;
            if (baseInfo.prefix !== utils_1.TNS_PREFIX) {
                childNsURI = this.definitions.xmlns[baseInfo.prefix];
            }
            var baseDef = this.findSchemaType(baseInfo.name, childNsURI);
            if (baseDef) {
                return this.findChildSchemaObject(baseDef, childName, backtrace);
            }
        }
        if (Array.isArray(object.children) && object.children.length > 0) {
            for(i = 0, child; child = object.children[i]; i++){
                found = this.findChildSchemaObject(child, childName, backtrace);
                if (found) {
                    break;
                }
                if (child.$base) {
                    var baseQName = utils_1.splitQName(child.$base);
                    var childNameSpace = baseQName.prefix === utils_1.TNS_PREFIX ? '' : baseQName.prefix;
                    childNsURI = child.xmlns[baseQName.prefix] || child.schemaXmlns[baseQName.prefix];
                    var foundBase = this.findSchemaType(baseQName.name, childNsURI);
                    if (foundBase) {
                        found = this.findChildSchemaObject(foundBase, childName, backtrace);
                        if (found) {
                            found.$baseNameSpace = childNameSpace;
                            found.$type = childNameSpace + ':' + childName;
                            break;
                        }
                    }
                }
            }
        }
        if (!found && object.$name === childName) {
            return object;
        }
        return found;
    };
    WSDL.prototype._initializeOptions = function(options) {
        this._originalIgnoredNamespaces = (options || {}).ignoredNamespaces;
        this.options = {};
        var ignoredNamespaces = options ? options.ignoredNamespaces : null;
        if (ignoredNamespaces && (Array.isArray(ignoredNamespaces.namespaces) || typeof ignoredNamespaces.namespaces === 'string')) {
            if (ignoredNamespaces.override) {
                this.options.ignoredNamespaces = ignoredNamespaces.namespaces;
            } else {
                this.options.ignoredNamespaces = this.ignoredNamespaces.concat(ignoredNamespaces.namespaces);
            }
        } else {
            this.options.ignoredNamespaces = this.ignoredNamespaces;
        }
        this.options.valueKey = options.valueKey || this.valueKey;
        this.options.xmlKey = options.xmlKey || this.xmlKey;
        if (options.escapeXML !== undefined) {
            this.options.escapeXML = options.escapeXML;
        } else {
            this.options.escapeXML = true;
        }
        if (options.returnFault !== undefined) {
            this.options.returnFault = options.returnFault;
        } else {
            this.options.returnFault = false;
        }
        this.options.handleNilAsNull = !!options.handleNilAsNull;
        if (options.namespaceArrayElements !== undefined) {
            this.options.namespaceArrayElements = options.namespaceArrayElements;
        } else {
            this.options.namespaceArrayElements = true;
        }
        // Allow any request headers to keep passing through
        this.options.wsdl_headers = options.wsdl_headers;
        this.options.wsdl_options = options.wsdl_options;
        if (options.httpClient) {
            this.options.httpClient = options.httpClient;
        }
        // The supplied request-object should be passed through
        if (options.request) {
            this.options.request = options.request;
        }
        var ignoreBaseNameSpaces = options ? options.ignoreBaseNameSpaces : null;
        if (ignoreBaseNameSpaces !== null && typeof ignoreBaseNameSpaces !== 'undefined') {
            this.options.ignoreBaseNameSpaces = ignoreBaseNameSpaces;
        } else {
            this.options.ignoreBaseNameSpaces = this.ignoreBaseNameSpaces;
        }
        // Works only in client
        this.options.forceSoap12Headers = options.forceSoap12Headers;
        this.options.customDeserializer = options.customDeserializer;
        if (options.overrideRootElement !== undefined) {
            this.options.overrideRootElement = options.overrideRootElement;
        }
        this.options.useEmptyTag = !!options.useEmptyTag;
    };
    WSDL.prototype._processNextInclude = function(includes, callback) {
        var _this = this;
        var include = includes.shift();
        if (!include) {
            return callback();
        }
        var includePath;
        if (!/^https?:/i.test(this.uri) && !/^https?:/i.test(include.location)) {
            var isFixed = this.options.wsdl_options !== undefined && this.options.wsdl_options.hasOwnProperty('fixedPath') ? this.options.wsdl_options.fixedPath : false;
            if (isFixed) {
                includePath = path.resolve(path.dirname(this.uri), path.parse(include.location).base);
            } else {
                includePath = path.resolve(path.dirname(this.uri), include.location);
            }
        } else {
            includePath = url.resolve(this.uri || '', include.location);
        }
        if (this.options.wsdl_options !== undefined && typeof this.options.wsdl_options.overrideImportLocation === 'function') {
            includePath = this.options.wsdl_options.overrideImportLocation(includePath);
        }
        var options = Object.assign({}, this.options);
        // follow supplied ignoredNamespaces option
        options.ignoredNamespaces = this._originalIgnoredNamespaces || this.options.ignoredNamespaces;
        options.WSDL_CACHE = this.WSDL_CACHE;
        open_wsdl_recursive(includePath, options, function(err, wsdl) {
            if (err) {
                return callback(err);
            }
            _this._includesWsdl.push(wsdl);
            if (wsdl.definitions instanceof elements.DefinitionsElement) {
                _.mergeWith(_this.definitions, wsdl.definitions, function(a, b) {
                    return a instanceof elements.SchemaElement ? a.merge(b) : undefined;
                });
            } else {
                return callback(new Error('wsdl.defintions is not an instance of elements.DefinitionsElement'));
            }
            _this._processNextInclude(includes, function(err) {
                callback(err);
            });
        });
    };
    WSDL.prototype._parse = function(xml) {
        var _this = this;
        var p = sax.parser(true, null);
        var stack = [];
        var root = null;
        var types = null;
        var schema = null;
        var schemaAttrs = null;
        var options = this.options;
        p.onopentag = function(node) {
            var nsName = node.name;
            var attrs = node.attributes;
            var top = stack[stack.length - 1];
            var name = utils_1.splitQName(nsName).name;
            if (name === 'schema') {
                schemaAttrs = attrs;
            }
            if (top) {
                try {
                    top.startElement(stack, nsName, attrs, options, schemaAttrs);
                } catch (e) {
                    if (_this.options.strict) {
                        throw e;
                    } else {
                        stack.push(new elements.Element(nsName, attrs, options, schemaAttrs));
                    }
                }
            } else {
                if (name === 'definitions') {
                    root = new elements.DefinitionsElement(nsName, attrs, options);
                    stack.push(root);
                } else if (name === 'schema') {
                    // Shim a structure in here to allow the proper objects to be created when merging back.
                    root = new elements.DefinitionsElement('definitions', {}, {});
                    types = new elements.TypesElement('types', {}, {});
                    schema = new elements.SchemaElement(nsName, attrs, options);
                    types.addChild(schema);
                    root.addChild(types);
                    stack.push(schema);
                } else {
                    throw new Error('Unexpected root element of WSDL or include');
                }
            }
        };
        p.onclosetag = function(name) {
            var top = stack[stack.length - 1];
            assert_1.ok(top, 'Unmatched close tag: ' + name);
            top.endElement(stack, name);
        };
        p.write(xml).close();
        return root;
    };
    WSDL.prototype._fromXML = function(xml) {
        this.definitions = this._parse(xml);
        this.definitions.descriptions = {
            types: {},
            elements: {}
        };
        this.xml = xml;
    };
    WSDL.prototype._fromServices = function(services) {};
    WSDL.prototype._xmlnsMap = function() {
        var xmlns = this.definitions.xmlns;
        var str = '';
        for(var alias in xmlns){
            if (alias === '' || alias === utils_1.TNS_PREFIX) {
                continue;
            }
            var ns = xmlns[alias];
            switch(ns){
                case 'http://xml.apache.org/xml-soap':
                case 'http://schemas.xmlsoap.org/wsdl/':
                case 'http://schemas.xmlsoap.org/wsdl/soap/':
                case 'http://schemas.xmlsoap.org/wsdl/soap12/':
                case 'http://schemas.xmlsoap.org/soap/encoding/':
                case 'http://www.w3.org/2001/XMLSchema':
                    continue;
            }
            if (~ns.indexOf('http://schemas.xmlsoap.org/')) {
                continue;
            }
            if (~ns.indexOf('http://www.w3.org/')) {
                continue;
            }
            if (~ns.indexOf('http://xml.apache.org/')) {
                continue;
            }
            str += ' xmlns:' + alias + '="' + ns + '"';
        }
        return str;
    };
    return WSDL;
}();
exports.WSDL = WSDL;
function open_wsdl_recursive(uri, p2, p3) {
    var fromCache;
    var WSDL_CACHE;
    var options;
    var callback;
    if (typeof p2 === 'function') {
        options = {};
        callback = p2;
    } else {
        options = p2;
        callback = p3;
    }
    WSDL_CACHE = options.WSDL_CACHE;
    if (fromCache = WSDL_CACHE[uri]) {
        return callback.call(fromCache, null, fromCache);
    }
    return open_wsdl(uri, options, callback);
}
function open_wsdl(uri, p2, p3) {
    var options;
    var callback;
    if (typeof p2 === 'function') {
        options = {};
        callback = p2;
    } else if (typeof p3 === 'function') {
        options = p2;
        callback = p3;
    }
    // initialize cache when calling open_wsdl directly
    var WSDL_CACHE = options.WSDL_CACHE || {};
    var request_headers = options.wsdl_headers;
    var request_options = options.wsdl_options;
    var wsdl;
    if (!/^https?:/i.test(uri)) {
        debug('Reading file: %s', uri);
        fs.readFile(uri, 'utf8', function(err, definition) {
            if (err) {
                callback(err);
            } else {
                wsdl = new WSDL(definition, uri, options);
                WSDL_CACHE[uri] = wsdl;
                wsdl.WSDL_CACHE = WSDL_CACHE;
                wsdl.onReady(callback);
            }
        });
    } else {
        debug('Reading url: %s', uri);
        var httpClient = options.httpClient || new http_1.HttpClient(options);
        httpClient.request(uri, null, function(err, response, definition) {
            if (err) {
                callback(err);
            } else if (response && response.status === 200) {
                wsdl = new WSDL(definition, uri, options);
                WSDL_CACHE[uri] = wsdl;
                wsdl.WSDL_CACHE = WSDL_CACHE;
                wsdl.onReady(callback);
            } else {
                callback(new Error('Invalid WSDL URL: ' + uri + '\n\n\r Code: ' + response.status + '\n\n\r Response Body: ' + response.data));
            }
        }, request_headers, request_options);
    }
    return wsdl;
}
exports.open_wsdl = open_wsdl; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/soap/lib/types.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.__esModule = true; //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/soap/lib/soap.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * Copyright (c) 2011 Vinay Pulim <vinay@milewise.com>
 * MIT Licensed
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);
};
exports.__esModule = true;
exports.listen = exports.createClientAsync = exports.createClient = exports.security = void 0;
var debugBuilder = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-rsc] (ecmascript)");
var client_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/client.js [app-rsc] (ecmascript)");
var _security = __turbopack_context__.r("[project]/node_modules/soap/lib/security/index.js [app-rsc] (ecmascript)");
var server_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/server.js [app-rsc] (ecmascript)");
var wsdl_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/wsdl/index.js [app-rsc] (ecmascript)");
var debug = debugBuilder('node-soap:soap');
exports.security = _security;
var client_2 = __turbopack_context__.r("[project]/node_modules/soap/lib/client.js [app-rsc] (ecmascript)");
__createBinding(exports, client_2, "Client");
var http_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/http.js [app-rsc] (ecmascript)");
__createBinding(exports, http_1, "HttpClient");
var security_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/security/index.js [app-rsc] (ecmascript)");
__createBinding(exports, security_1, "BasicAuthSecurity");
__createBinding(exports, security_1, "BearerSecurity");
__createBinding(exports, security_1, "ClientSSLSecurity");
__createBinding(exports, security_1, "ClientSSLSecurityPFX");
__createBinding(exports, security_1, "NTLMSecurity");
__createBinding(exports, security_1, "WSSecurity");
__createBinding(exports, security_1, "WSSecurityCert");
var server_2 = __turbopack_context__.r("[project]/node_modules/soap/lib/server.js [app-rsc] (ecmascript)");
__createBinding(exports, server_2, "Server");
var utils_1 = __turbopack_context__.r("[project]/node_modules/soap/lib/utils.js [app-rsc] (ecmascript)");
__createBinding(exports, utils_1, "passwordDigest");
__exportStar(__turbopack_context__.r("[project]/node_modules/soap/lib/types.js [app-rsc] (ecmascript)"), exports);
var wsdl_2 = __turbopack_context__.r("[project]/node_modules/soap/lib/wsdl/index.js [app-rsc] (ecmascript)");
__createBinding(exports, wsdl_2, "WSDL");
function createCache() {
    var cache = {};
    return function(key, load, callback) {
        if (!cache[key]) {
            load(function(err, result) {
                if (err) {
                    return callback(err);
                }
                cache[key] = result;
                callback(null, result);
            });
        } else {
            process.nextTick(function() {
                callback(null, cache[key]);
            });
        }
    };
}
var getFromCache = createCache();
function _requestWSDL(url, options, callback) {
    if (typeof options === 'function') {
        callback = options;
        options = {};
    }
    var openWsdl = function(callback) {
        wsdl_1.open_wsdl(url, options, callback);
    };
    if (options.disableCache === true) {
        openWsdl(callback);
    } else {
        getFromCache(url, openWsdl, callback);
    }
}
function createClient(url, p2, p3, p4) {
    var endpoint = p4;
    var callback;
    var options;
    if (typeof p2 === 'function') {
        callback = p2;
        endpoint = p3;
        options = {};
    } else if (typeof p3 === 'function') {
        options = p2;
        callback = p3;
        endpoint = p4;
    }
    endpoint = options.endpoint || endpoint;
    _requestWSDL(url, options, function(err, wsdl) {
        callback(err, wsdl && new client_1.Client(wsdl, endpoint, options));
    });
}
exports.createClient = createClient;
function createClientAsync(url, options, endpoint) {
    if (typeof options === 'undefined') {
        options = {};
    }
    return new Promise(function(resolve, reject) {
        createClient(url, options, function(err, client) {
            if (err) {
                reject(err);
            }
            resolve(client);
        }, endpoint);
    });
}
exports.createClientAsync = createClientAsync;
function listen(server, p2, services, xml, callback) {
    var options;
    var path;
    var uri = '';
    if (typeof p2 === 'object' && !(p2 instanceof RegExp)) {
        // p2 is options
        // server, options
        options = p2;
        path = options.path;
        services = options.services;
        xml = options.xml;
        uri = options.uri;
    } else {
        // p2 is path
        // server, path, services, wsdl
        path = p2;
        options = {
            path: p2,
            services: services,
            callback: callback
        };
    }
    var wsdl = new wsdl_1.WSDL(xml || services, uri, options);
    return new server_1.Server(server, path, services, wsdl, options);
}
exports.listen = listen; //# sourceMappingURL=soap.js.map
}),
"[project]/node_modules/soap/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/soap/lib/soap.js [app-rsc] (ecmascript)");
}),
];

//# sourceMappingURL=node_modules_soap_5e91b088._.js.map